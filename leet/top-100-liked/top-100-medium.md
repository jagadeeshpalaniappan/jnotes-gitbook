# 2. Top 100 - MEDIUM

## Index

| \# | qId | Title | freqStars |
| :--- | :--- | :--- | :--- |
| 1 | 2 | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers) | \*\*\*\*\*\* |
| 2 | 146 | [LRU Cache    ](https://leetcode.com/problems/lru-cache) | \*\*\*\*\*\* |
| 3 | 5 | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring) | \*\*\*\*\*\* |
| 4 | 200 | [Number of Islands](https://leetcode.com/problems/number-of-islands) | \*\*\*\*\* |
| 5 | 3 | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters) | \*\*\*\*\* |
| 6 | 15 | [3Sum](https://leetcode.com/problems/3sum) | \*\*\*\*\* |
| 7 | 238 | [Product of Array Except Self    ](https://leetcode.com/problems/product-of-array-except-self) | \*\*\*\* |
| 8 | 56 | [Merge Intervals    ](https://leetcode.com/problems/merge-intervals) | \*\*\*\* |
| 9 | 33 | [Search in Rotated Sorted Array    ](https://leetcode.com/problems/search-in-rotated-sorted-array) | \*\*\*\* |
| 10 | 253 | [Meeting Rooms II    ](https://leetcode.com/problems/meeting-rooms-ii) | \*\*\*\* |
| 11 | 49 | [Group Anagrams    ](https://leetcode.com/problems/group-anagrams) | \*\*\*\* |
| 12 | 22 | [Generate Parentheses    ](https://leetcode.com/problems/generate-parentheses) | \*\*\*\* |
| 13 | 11 | [Container With Most Water    ](https://leetcode.com/problems/container-with-most-water) | \*\*\*\* |
| 14 | 560 | [Subarray Sum Equals K    ](https://leetcode.com/problems/subarray-sum-equals-k) | \*\*\*\* |
| 15 | 394 | [Decode String    ](https://leetcode.com/problems/decode-string) | \*\*\*\* |
| 16 | 17 | [Letter Combinations of a Phone Number    ](https://leetcode.com/problems/letter-combinations-of-a-phone-number) | \*\*\*\* |
| 17 | 79 | [Word Search    ](https://leetcode.com/problems/word-search) | \*\*\* |
| 18 | 31 | [Next Permutation    ](https://leetcode.com/problems/next-permutation) | \*\*\* |
| 19 | 46 | [Permutations    ](https://leetcode.com/problems/permutations) | \*\*\* |
| 20 | 139 | [Word Break    ](https://leetcode.com/problems/word-break) | \*\*\* |
| 21 | 322 | [Coin Change    ](https://leetcode.com/problems/coin-change) | \*\*\* |
| 22 | 215 | [Kth Largest Element in an Array    ](https://leetcode.com/problems/kth-largest-element-in-an-array) | \*\*\* |
| 23 | 347 | [Top K Frequent Elements    ](https://leetcode.com/problems/top-k-frequent-elements) | \*\*\* |
| 24 | 221 | [Maximal Square    ](https://leetcode.com/problems/maximal-square) | \*\*\* |
| 25 | 39 | [Combination Sum    ](https://leetcode.com/problems/combination-sum) | \*\*\* |
| 26 | 98 | [Validate Binary Search Tree    ](https://leetcode.com/problems/validate-binary-search-tree) | \*\*\* |
| 27 | 78 | [Subsets    ](https://leetcode.com/problems/subsets) | \*\*\* |
| 28 | 621 | [Task Scheduler    ](https://leetcode.com/problems/task-scheduler) | \*\*\* |
| 29 | 48 | [Rotate Image    ](https://leetcode.com/problems/rotate-image) | \*\*\* |
| 30 | 152 | [Maximum Product Subarray    ](https://leetcode.com/problems/maximum-product-subarray) | \*\*\* |
| 31 | 236 | [Lowest Common Ancestor of a Binary Tree    ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree) | \*\*\* |
| 32 | 207 | [Course Schedule    ](https://leetcode.com/problems/course-schedule) | \*\*\* |
| 33 | 64 | [Minimum Path Sum    ](https://leetcode.com/problems/minimum-path-sum) | \*\*\* |
| 34 | 240 | [Search a 2D Matrix II    ](https://leetcode.com/problems/search-a-2d-matrix-ii) | \*\*\* |
| 35 | 300 | [Longest Increasing Subsequence    ](https://leetcode.com/problems/longest-increasing-subsequence) | \*\*\* |
| 36 | 438 | [Find All Anagrams in a String    ](https://leetcode.com/problems/find-all-anagrams-in-a-string) | \*\*\* |
| 37 | 34 | [Find First and Last Position of Element in Sorted Array    ](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array) | \*\*\* |
| 38 | 148 | [Sort List    ](https://leetcode.com/problems/sort-list) | \*\*\* |
| 39 | 102 | [Binary Tree Level Order Traversal    ](https://leetcode.com/problems/binary-tree-level-order-traversal) | \*\* |
| 40 | 75 | [Sort Colors    ](https://leetcode.com/problems/sort-colors) | \*\* |
| 41 | 739 | [Daily Temperatures    ](https://leetcode.com/problems/daily-temperatures) | \*\* |
| 42 | 647 | [Palindromic Substrings    ](https://leetcode.com/problems/palindromic-substrings) | \*\* |
| 43 | 96 | [Unique Binary Search Trees    ](https://leetcode.com/problems/unique-binary-search-trees) | \*\* |
| 44 | 105 | [Construct Binary Tree from Preorder and Inorder Traversal    ](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal) | \*\* |
| 45 | 208 | [Implement Trie \(Prefix Tree\)    ](https://leetcode.com/problems/implement-trie-prefix-tree) | \*\* |
| 46 | 309 | [Best Time to Buy and Sell Stock with Cooldown    ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown) | \*\* |
| 47 | 19 | [Remove Nth Node From End of List    ](https://leetcode.com/problems/remove-nth-node-from-end-of-list) | \*\* |
| 48 | 94 | [Binary Tree Inorder Traversal    ](https://leetcode.com/problems/binary-tree-inorder-traversal) | \*\* |
| 49 | 287 | [Find the Duplicate Number    ](https://leetcode.com/problems/find-the-duplicate-number) | \*\* |
| 50 | 416 | [Partition Equal Subset Sum    ](https://leetcode.com/problems/partition-equal-subset-sum) | \*\* |
| 51 | 55 | [Jump Game    ](https://leetcode.com/problems/jump-game) | \*\* |
| 52 | 62 | [Unique Paths    ](https://leetcode.com/problems/unique-paths) | \*\* |
| 53 | 406 | [Queue Reconstruction by Height    ](https://leetcode.com/problems/queue-reconstruction-by-height) | \*\* |
| 54 | 114 | [Flatten Binary Tree to Linked List    ](https://leetcode.com/problems/flatten-binary-tree-to-linked-list) | \*\* |
| 55 | 399 | [Evaluate Division    ](https://leetcode.com/problems/evaluate-division) | \*\* |
| 56 | 279 | [Perfect Squares    ](https://leetcode.com/problems/perfect-squares) | \*\* |
| 57 | 142 | [Linked List Cycle II    ](https://leetcode.com/problems/linked-list-cycle-ii) | \* |
| 58 | 338 | [Counting Bits    ](https://leetcode.com/problems/counting-bits) | \* |
| 59 | 494 | [Target Sum    ](https://leetcode.com/problems/target-sum) | \* |
| 60 | 337 | [House Robber III    ](https://leetcode.com/problems/house-robber-iii) | \* |



## [1. Add Two Numbers](https://leetcode.com/problems/add-two-numbers)

{% tabs %}
{% tab title="Question" %}
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example:**

```text
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=esZdwGfG7NE" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*
Sol1: [BEST] Since 'list1' & 'list2' are already in reverseOrder. It is easy to do addition

  |      |      |
  V      V      V
342     342     342
465     465     465
----    ----    ----
  7      07     807
----    ----    ----

  2 ----> 4 ----> 3
  5 ----> 6 ----> 4
 --------------------
  7 ----> 0 ----> 8
 --------------------


Time complexity : O(max(m,n))   // m: l1.length and n: l2.length
Space complexity : O(max(m,n))  // resultList.length
if we dont consider, 'resultList' Space // Space complexity : O(1)
*/
function addTwoNumbers(l1, l2) {
  let resultList = new ListNode(0); // dummyNode
  let resIter = resultList; // 'resultList' iterator

  let p = l1; // 'l1' iterator
  let q = l2; // 'l2' iterator

  let carryFwd = 0;

  while (p !== null || q !== null || carryFwd !== 0) {
    let totalSum = 0;

    if (p !== null) {
      totalSum = totalSum + p.val;
      p = p.next; // next: iter
    }
    if (q !== null) {
      totalSum = totalSum + q.val;
      q = q.next; // next: iter
    }
    totalSum = totalSum + carryFwd;

    // totalSumLastDigit:
    const totalSumLastDigit = totalSum % 10;
    resIter.next = new ListNode(totalSumLastDigit);

    // totalSumExcludeLastDigit:
    carryFwd = Math.floor(totalSum / 10);

    resIter = resIter.next; // next: iter
  }

  // ignore: dummyNode
  return resultList.next;
}
```
{% endtab %}
{% endtabs %}

## 2. LRU

{% tabs %}
{% tab title="Question" %}
Design and implement a data structure for [Least Recently Used \(LRU\) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). 

* It should support the following operations: `get` and `put` in **`O(1) time`**
* `get(key)` - get the value by key \(if not exists return -1\) 
  * whenever get\(key\) happens, consider that particular item is _**recently used**_
* `put(key, val)` - add/update the key and value 
  * when the cache reached its max capacity, it should remove Least Recently Used item
  * and add the new item
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=S6IfqDXWa10" %}
{% endtab %}

{% tab title="Result Walkthrough" %}
**Solution:  `HashMap` + `DoublyLinkedList`** 

* `HM`: for quick access // **get**, add, remove in O\(1\) time 
* `DLL`: for maintaining the 'recentlyUsedItems' order // **reArrange**, add, remove in O\(1\) time 

**TimeComplexity**: O\(1\) both for put and get. **SpaceComplexity** : O\(capacity\)

```java

LRUCache obj = new LRUCache(5);
obj.put(1, 11);
// addNewItem
// DLL: H--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1 }

obj.put(2, 22);
// addNewItem
// DLL: H--> <--[prev]DLNode2[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2 }


obj.put(3, 33);
// addNewItem
// DLL: H--> <--[prev]DLNode3[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3 }


obj.get(2); // 22
// updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3 }


obj.put(1, 111);
// updateExistingItemVal & updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--T
// HM: { 1: **DLNode1**, 2: DLNode2, 3: DLNode3 }


obj.put(4, 44);
// addNewItem
// DLL: H--> <--[prev]DLNode4[next]--><--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3, 4: DLNode4 }



obj.put(5, 55);
// addNewItem
// DLL: H--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3, 4: DLNode4, 5: DLNode5 }


obj.put(6, 66);
// addNewItem, removedLeastRecentlyUsedItem (DLL's lastItem - DLNode3)
// DLL: H--> <--[prev]DLNode6[next]--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 4: DLNode4, 5: DLNode5, 6: DLNode6 }



obj.put(7, 77);
// addNewItem, removedLeastRecentlyUsedItem (DLL's lastItem - DLNode3)
// DLL: H--> <--[prev]DLNode7[next]--> <--[prev]DLNode6[next]--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 4: DLNode4, 5: DLNode5, 6: DLNode6, 7: DLNode7 }



obj.get(1);
// updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode1[next]--> <--[prev]DLNode7[next]--> <--[prev]DLNode6[next]--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--T
// HM: { 1: DLNode1, 4: DLNode4, 5: DLNode5, 6: DLNode6, 7: DLNode7 }



obj.put(5, 555);
// updateExistingItemVal & updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode5[next]--> <--[prev]DLNode1[next]--> <--[prev]DLNode7[next]--> <--[prev]DLNode6[next]--> <--[prev]DLNode4[next]--> <--T
// HM: { 1: DLNode1, 4: DLNode4, 5: **DLNode5**, 6: DLNode6, 7: DLNode7 }



```
{% endtab %}

{% tab title="Code" %}


```java

class LRUCache {

    /* ------------------------ Doubly Linked List  ------------------------ */

    private DLLNode head, tail;

    private class DLLNode {
        int key;
        int value;
        DLLNode prev;
        DLLNode next;
    }

    /*
      insert: 'newNode' into 'HEAD' of the Double Linked List

        ## 1. populate: 'newNode'
           headNode <-- '[prev] newNode [next]' --> previousFirstNode

        ## 2. update: 'headNode.next' and 'previousFirstNode.prev'
           headNode[next] --> 'newNode' <-- previousFirstNode[prev]
    */
    private void addNode(DLLNode newNode){
        DLLNode previousFirstNode = head.next;

        // ## 1. populate: 'newNode'
        newNode.prev = head;
        newNode.next = previousFirstNode;

        // ## 2. update: 'headNode.next' and 'previousFirstNode.prev'
        head.next = newNode;
        previousFirstNode.prev = newNode; // previousFirstNode.prev = newNode
    }

    /*
      remove: 'targetNode' from Double Linked List

      ## 1. get: 'targetNodePrevNode' & 'targetNodeNextNode'
          targetNodePrevNode <-- [prev] targetNode [next] --> targetNodeNextNode

      ## 2. populate: 'targetNodePrevNode.next' & 'targetNodeNextNode.prev'
          targetNodePrevNode[next] --> targetNodeNextNode
          targetNodePrevNode <-- [prev] targetNodeNextNode

    */
    private void removeNode(DLLNode targetNode){

        // ## 1. get: 'targetNodePrevNode' & 'targetNodeNextNode'
        DLLNode targetNodePrevNode = targetNode.prev;
        DLLNode targetNodeNextNode = targetNode.next;

        // ## 2. populate: 'targetNodePrevNode.next' & 'targetNodeNextNode.prev'
        targetNodePrevNode.next = targetNodeNextNode;
        targetNodeNextNode.prev = targetNodePrevNode;
    }

    /*
      Move a node to the head of the doubly linked lsit
       1. remove the targetNode from doubly linked lsit
       1. add the targetNode to starting position of doubly linked lsit
    */
    private void moveToHead(DLLNode node){
        removeNode(node);
        addNode(node);
    }

    /*
      Pop the last item from the structure
    */
    private DLLNode popTail(){
        DLLNode lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }


    /* ------------------------ / Doubly Linked List  ------------------------ */

    private Map<Integer, DLLNode> hashMap = new HashMap<>();

    private int totalItemsInCache;
    private int maxCapacity;

    public LRUCache(int maxCapacity) {

        // Cache starts empty and capacity is set by client
        totalItemsInCache = 0;
        this.maxCapacity = maxCapacity;

        // Initialize the dummy head of the hashMap
        head = new DLLNode();
        head.prev = null;

        // Init the dummy tail of the hashMap
        tail = new DLLNode();
        tail.next = null;

        // Wire the head and tail together
        head.next = tail;
        tail.prev = head;
    }

    /*
      Retrieve an item from the hashMap
    */
    public int get(int key) {
        DLLNode node = hashMap.get(key);

        if (node == null) {
            // targetItem not available
            return -1;
        } else {
            // targetItem available
            // targetItem has been accessed,  move: 'targetItem' to the front of the Linked List.
            moveToHead(node);
            return node.value;
        }
    }

    /*
      addItem or updateItem
      addItem: add + ifApplicableRemoveLRU
      updateItem: updateVal + updateRecentlyUsedItem
    */
    public void put(int key, int value) {

        DLLNode node = hashMap.get(key);
        if (node == null) {
            // targetItem not available,
            //  1. add the 'newEntry' in the Map
            //  2. add the 'newNode' in the DLL
            //  3. check: whether we have reached the maxCapacity
            //      if: yes --> remove the (DLL's lastItem) from DLL and Map as 'LRU eviction policy'

            // populate: newNode
            DLLNode newNode = new DLLNode();
            newNode.key = key;
            newNode.value = value;

            // 1. add the 'newEntry' in the Map
            hashMap.put(key, newNode);
            // 2. add the 'newNode' in the DLL
            addNode(newNode);


            // 3. check: whether we have reached the maxCapacity
            totalItemsInCache++; // we just added an item to the hashMap & DLL

            // If over capacity evict an item with LRU eviction policy
            if(totalItemsInCache > maxCapacity){
                removeLRUEntryFromStructure();
            }

        } else {
            // targetItem available,
            // 1. update: the 'targetItem' with new value
            // 2. targetItem has been accessed,  move: 'targetItem' to the front of the Linked List.
            node.value = value;
            moveToHead(node);
        }

    }

    /*
      remove the (DLL's lastItem) from DLL and Map as per 'LRU eviction policy'
    */
    private void removeLRUEntryFromStructure() {
        DLLNode tail = popTail();
        hashMap.remove(tail.key);
        --totalItemsInCache;
    }


}
```
{% endtab %}

{% tab title="Quick Code" %}
```java
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;
    
    public LRUCache(int capacity) {
        // LinkedHashMap
        // arg1: capacity, arg2: loadFactor, arg3: isAccessOrder
        // arg3: "false" for insertion-order (default), "true" for access-order 
        super(capacity, 0.75F, true);
        
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
{% endtab %}
{% endtabs %}

## [3. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring) 

{% tabs %}
{% tab title="Question" %}
**5. Longest Palindromic Substring**

* Given a string **s**, find the longest palindromic substring in **s**. 
* You may assume that the maximum length of **s** is 1000.

**Example 1:**

```text
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```

**Example 2:**

```text
Input: "cbbd"
Output: "bb"
```
{% endtab %}

{% tab title="Video" %}
1. [https://www.youtube.com/watch?v=onkdOAMS63U](https://www.youtube.com/watch?v=onkdOAMS63U)

**DP:**  Time: O\(n\), Space: O\(n^2\)

1. [https://www.youtube.com/watch?v=obBdxeCx\_Qs](https://www.youtube.com/watch?v=obBdxeCx_Qs)
2. [https://www.youtube.com/watch?v=Fi5INvcmDos](https://www.youtube.com/watch?v=Fi5INvcmDos)

\*\*\*\*

**Expand Around Center Alg:**  Time: O\(n^2\), Space: O\(1\)

**Manchester's Alg:**  Time: O\(n\), Space: O\(n\)  `[BEST]`

1. [https://www.youtube.com/watch?v=SV1ZaKCozS4](https://www.youtube.com/watch?v=SV1ZaKCozS4) \[BEST\]
2. [https://www.youtube.com/watch?v=kbUiR5YWUpQ](https://www.youtube.com/watch?v=kbUiR5YWUpQ)
3. [https://www.youtube.com/watch?v=nbTSfrEfo6M](https://www.youtube.com/watch?v=nbTSfrEfo6M)
4. [http://manacher-viz.s3-website-us-east-1.amazonaws.com/\#/](http://manacher-viz.s3-website-us-east-1.amazonaws.com/#/)
{% endtab %}

{% tab title="Sol: \[EASY\]" %}
```javascript
/*
Using: 'Expand Around Center' approach [ JAG ]

// This is better for interview

// Time complexity : O(n^2) // Space complexity : O(1)
*/
function longestPalindrome(s) {
  if (s === null || s.length < 1) return "";
  let startIndex = 0;
  let endIndex = 0;

  let maxPalin = { length: 0 };

  for (let i = 0; i < s.length; i++) {
    let oddPalind = expandAroundCenter(s, i, i);
    let evenPalind = expandAroundCenter(s, i, i + 1);

    // currPalin: max(oddPalindLen, evenPalindLen)
    let currPalin =
      oddPalind.length > evenPalind.length ? oddPalind : evenPalind;

    // update: maxPalin
    maxPalin = currPalin.length > maxPalin.length ? currPalin : maxPalin;
  }
  return s.slice(maxPalin.start, maxPalin.end + 1);
}

function expandAroundCenter(s, left, right) {
  while (s[left] && s[right] && s[left] === s[right]) {
    left--;
    right++;
  }

  const start = left + 1;
  const end = right - 1;
  const length = end - start <= 0 ? 0 : end - start + 1;
  return { start, end, length };
}
```
{% endtab %}

{% tab title="Sol: \[BEST\]" %}
```javascript
/*
Using: Manacher algorithm  
// (This is NOT better for interview, becoz nobody get this solution in 40min interview)

// Time complexity : O(n) // Space complexity : O(n)
*/
function longestPalindrome(s) {
  let T = "$#" + s.split("").join("#") + "#@";
  // palindrome: for eachChar 
  let P = Array(T.length).fill(0);
  let center = 0;
  let right = 0;

  for (let i = 0; i < T.length; i++) {
    let mirr = 2 * center - i;

    // 1. if: 'currIndex' is within the 'rightBoundary'
    // then: try to use the palidrome 'mirror' value
    if (i < right) P[i] = Math.min(right - i, P[mirr]);

    // 2. expand:
    while (T[i + (1 + P[i])] === T[i - (1 + P[i])]) P[i]++;

    // 3. Is 'currPalindromeRightBoundary' is greater than 'rightBoundary'
    // then: update the 'center' and 'rightBoundary'
    if (i + P[i] > right) {
      center = i;
      right = i + P[i];
    }
  }

  let maxlength = 0; // length of longest palindromic substring
  let maxCenter = 0; // center of longest palindromic substring
  for (let i = 0; i < P.length; i++) {
    if (P[i] > maxlength) {
      maxlength = P[i];
      maxCenter = i;
    }
  }

  return s.substring(
    (maxCenter - 1 - maxlength) / 2,
    (maxCenter - 1 + maxlength) / 2
  );
}
```
{% endtab %}

{% tab title="Sol: \[dp\]" %}
```javascript
/*
 Use: dpTable -to store the previous computations
 // (This is NOT better for interview, becoz it is complex and consider 'expandAroundCenter' approach with same timeComplexity)

 // Time complexity : O(n^2) // Space complexity : O(n^2)
*/
function lps(s) {
  let n = s.length;
  let palindromeBeginsAt = 0; //index where the longest dpTable begins
  let maxSubStrLenSoFar = 1; //length of the longest dpTable
  let dpTable = []; //boolean table to store dpTable truth

  // Populate: 'dpTable' // In this process, also update the max(maxSubStrLenSoFar)

  // 1. Base Case: ‘1 char substring’ - is always ‘palindrome’
  for (let i = 0; i < n; i++) {
    dpTable[i][i] = true;
  }

  // 2. Base Case: if: '2 char substring' - Is 'first and last char same' - then it is a 'dpTable'
  for (let i = 0; i < n - 1; i++) {
    const first = s[i];
    const last = s[i + 1];
    if (first === last) {
      dpTable[i][i + 1] = true;
      palindromeBeginsAt = i;
      maxSubStrLenSoFar = 2;
    }
  }

  // 3. if: ‘3+ char substring’
  // - [3.1] Is ‘first and last char same’ and [3.2] Is ‘middleSubStr palidrome (check: fromAlreadyComputed-DP)’
  // - then it is a ‘palindrome’

  // for: (3 to n) - to find the comibinations of substr
  for (let currSubStrLen = 3; currSubStrLen <= n; currSubStrLen++) {

    // populate: 'substr' for 'currSubStr'
    const substrEndIndex = n - currSubStrLen + 1;
    for (let i = 0; i < substrEndIndex; i++) {
      let firstCharIndex = i;
      let lastCharIndex = i + currSubStrLen - 1;

      // 3.1 Is 'first' & 'last' char of currSubStr 'Same' ?
      let isFirstAndLastCharSame = s[firstCharIndex] === s[lastCharIndex];
      // 3.2 Is ‘middleSubStr palidrome (check: fromAlreadyComputed-dpTable)
      let isMiddleSubStrPalindrome = dpTable[firstCharIndex + 1][lastCharIndex - 1];

      if (isFirstAndLastCharSame && isMiddleSubStrPalindrome) {
        // store: currSubStr is Palindrome
        dpTable[firstCharIndex][lastCharIndex] = true;
        palindromeBeginsAt = firstCharIndex;
        maxSubStrLenSoFar = currSubStrLen;
      }
    }
  }
  return s.slice(palindromeBeginsAt, maxSubStrLenSoFar + palindromeBeginsAt);
}

```
{% endtab %}
{% endtabs %}

## [4. Number of Islands](https://leetcode.com/problems/number-of-islands)

{% tabs %}
{% tab title="Question" %}
**200. Number of Islands**

Given a 2d grid map of `'1'`s \(land\) and `'0'`s \(water\), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```text
Input:
11110
11010
11000
00000

Output: 1
```

**Example 2:**

```text
Input:
11000
11000
00100
00011

Output: 3
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=CGMNePwovA0" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*
 Using: DFS

 Linear scan the 2d grid map, 
  - if a node contains a '1', then it is a root node that triggers a Depth First Search. 
  - During DFS, every visited node should be set as '0' to mark as visited node. 
  - Count the number of root nodes that trigger DFS, 
      - this number would be the number of islands since each DFS starting at some root identifies an island.

Steps:
  // 1. found a land // currNode is '1'
  // 2. try 'DFS' to see whether we can acquire nearby land
        // 2.1 (not-acquired) land found
            - acquire it:  by marking currNode as '0' (visited/acquired/markItUnAvailableForNextTime)
        // 2.2 go all direction and try 'DFS' to see whether we can acquire nearby land

 // Time complexity : O(n^2) // Space complexity : O(n^2)

 
 Time complexity : O(M×N) where M is the number of rows and N is the number of columns.
 Space complexity : worst case O(M×N) in case that the grid map is filled with lands where DFS goes by NM×N deep.
*/

// [JAG]
function dfs(grid, r, c) {
  // base-case:
  // currNode: shouldBeWithinBoundary & shouldNotBeZero
  if (!grid[r] || !grid[r][c] || grid[r][c] === "0") return;

  // 2.1 (not-acquired) land found
  // acquire it:  by marking currNode as '0' (visited/acquired/markItUnAvailableForNextTime)
  grid[r][c] = "0";

  // 2.2 go all direction and try 'DFS' to see whether we can acquire nearby land
  dfs(grid, r - 1, c);
  dfs(grid, r + 1, c);
  dfs(grid, r, c - 1);
  dfs(grid, r, c + 1);
}

function numIslands(grid) {
  if (!grid || !grid.length) return 0;

  let count = 0;
  const nr = grid.length; // noOfRow
  const nc = grid[0].length; // noOfCols

  for (let r = 0; r < nr; r++) {
    for (let c = 0; c < nc; c++) {
      if (grid[r][c] === "1") {
        // 1. found a land // currNode is '1'
        count = count + 1;

        // 2. try 'DFS' to see whether we can acquire nearby land
        dfs(grid, r, c);
      }
    }
  }
  return count;
}

const grid1 = [
  ["1", "1", "1", "1", "0"],
  ["1", "1", "0", "1", "0"],
  ["1", "1", "0", "0", "0"],
  ["0", "0", "0", "0", "0"]
];
console.log(numIslands(grid1)); // 1

```
{% endtab %}
{% endtabs %}



## [5. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters)

{% tabs %}
{% tab title="Question" %}
**3. Longest Substring Without Repeating Characters**

Given a string, find the length of the **longest substring** without repeating characters.

**Example 1:**

```text
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 
```

**Example 2:**

```text
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```text
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
```
{% endtab %}

{% tab title="Video" %}
* [https://www.youtube.com/watch?v=aIrbWbON63M](https://www.youtube.com/watch?v=aIrbWbON63M)
* [https://www.youtube.com/watch?v=8ZlmgBcQzMM](https://www.youtube.com/watch?v=8ZlmgBcQzMM)
{% endtab %}

{% tab title="Code" %}
```javascript
/*
Using 'Sliding Window' (Set and Two Pointer)

// Time complexity : O(2n) = O(n) // In the worst case each character will be visited twice by i and j.
// Space complexity : O(min(m, n))  // size of the charset 'm' or size of the string 'n' // whichever is minimum
*/
function lengthOfLongestSubstring(s) {
  let maxSofar = 0;
  const charSet = new Set();

  // leftPtr & rightPtr
  let l = 0,
    r = 0;
  while (l < s.length && r < s.length) {
    const currChar = s[r];

    if (!charSet.has(currChar)) {
      // itemNotFoundInSet: consider 'currChar' as part of prevSubStr

      // add: currChar in Set
      charSet.add(currChar);

      // eval: maxSubStrLen
      const currSubStrLen = r - l + 1; // subStrlen = endIndex - startIndex + 1 // formula
      maxSofar = Math.max(maxSofar, currSubStrLen);

      // move 'rightPtr' to 'nextItem'
      r++;
    } else {
      // itemFoundInSet: delete the leftPtrItem from Set
      charSet.delete(s[l]);

      // move 'leftPtr' to 'nextItem'
      l++;
    }
  }
  return maxSofar;
}
```
{% endtab %}

{% tab title="Sol2: \[BEST\]" %}
```javascript

/*
Using 'Sliding Window (Improved)' (Map and Two Pointer) [BEST]

// Time complexity : O(n) 
// Space complexity : O(min(m, n))  // size of the charset 'm' or size of the string 'n' // whichever is minimum
*/
function lengthOfLongestSubstring(s) {
  if (s.length == 0) return 0;
  let maxSofar = 0;

  // { eachChar: index }
  const charMap = new Map();

  // leftPtr & rightPtr
  let l = 0,
    r = 0;
  while (r < s.length) {
    const currChar = s[r];

    if (charMap.has(currChar)) {
      // itemFoundInSet: jump the 'leftPtr' to existingCharIndex and move 'leftPtr' to 'nextItem'
      // whichever is greater consider that as 'leftPtr'
      l = Math.max(l, charMap.get(currChar) + 1);
    }

    // add: currChar in Set
    charMap.set(currChar, r);

    // eval: maxSubStrLen
    const currSubStrLen = r - l + 1; // subStrlen = endIndex - startIndex + 1 // formula
    maxSofar = Math.max(maxSofar, currSubStrLen);

    // move 'rightPtr' to 'nextItem'
    r++;
  }

  return maxSofar;
}

```
{% endtab %}
{% endtabs %}

## [6. 3Sum](https://leetcode.com/problems/3sum)

{% tabs %}
{% tab title="Question" %}
**15. 3Sum**

Given an array `nums` of _n_ integers, are there elements _a_, _b_, _c_ in `nums` such that _a_ + _b_ + _c_ = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:**

The solution set must not contain duplicate triplets.

**Example:**

```text
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
{% endtab %}

{% tab title="Video" %}
* [https://www.youtube.com/watch?v=jXZDUdHRbhY](https://www.youtube.com/watch?v=jXZDUdHRbhY)
* [https://www.youtube.com/watch?v=X5UhF3xS5Dk](https://www.youtube.com/watch?v=X5UhF3xS5Dk)
* [https://www.youtube.com/watch?v=-AMHUdZc9ss](https://www.youtube.com/watch?v=-AMHUdZc9ss)
{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..\#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}



## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..\#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}



## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..\#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}



## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..\#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}



## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..\#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}



## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..

