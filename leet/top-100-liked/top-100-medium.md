# 2. Top 100 - MEDIUM

## Index

| \# | qId | Title | freqStars |
| :--- | :--- | :--- | :--- |
| 1 | 2 | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers) | \*\*\*\*\*\* |
| 2 | 146 | [LRU Cache    ](https://leetcode.com/problems/lru-cache) | \*\*\*\*\*\* |
| 3 | 5 | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring) | \*\*\*\*\*\* |
| 4 | 200 | [Number of Islands](https://leetcode.com/problems/number-of-islands) | \*\*\*\*\* |
| 5 | 3 | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters) | \*\*\*\*\* |
| 6 | 15 | [3Sum](https://leetcode.com/problems/3sum) | \*\*\*\*\* |
| 7 | 238 | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self) | \*\*\*\* |
| 8 | 56 | [Merge Intervals](https://leetcode.com/problems/merge-intervals) | \*\*\*\* |
| 9 | 33 | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array) | \*\*\*\* |
| 10 | 253 | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii) | \*\*\*\* |
| 11 | 49 | [Group Anagrams](https://leetcode.com/problems/group-anagrams) | \*\*\*\* |
| 12 | 22 | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses) | \*\*\*\* |
| 13 | 11 | [Container With Most Water](https://leetcode.com/problems/container-with-most-water) | \*\*\*\* |
| 14 | 560 | [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k) | \*\*\*\* |
| 15 | 394 | [Decode String](https://leetcode.com/problems/decode-string) | \*\*\*\* |
| 16 | 17 | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number) | \*\*\*\* |
| 17 | 79 | [Word Search](https://leetcode.com/problems/word-search) | \*\*\* |
| 18 | 31 | [Next Permutation](https://leetcode.com/problems/next-permutation) TODO | \*\*\* |
| 19 | 46 | [Permutations](https://leetcode.com/problems/permutations) TODO | \*\*\* |
| 20 | 139 | [Word Break](https://leetcode.com/problems/word-break) | \*\*\* |
| 21 | 322 | [Coin Change](https://leetcode.com/problems/coin-change) | \*\*\* |
| 22 | 215 | [Kth Largest Element in an Array    ](https://leetcode.com/problems/kth-largest-element-in-an-array) | \*\*\* |
| 23 | 347 | [Top K Frequent Elements    ](https://leetcode.com/problems/top-k-frequent-elements) | \*\*\* |
| 24 | 221 | [Maximal Square    ](https://leetcode.com/problems/maximal-square) | \*\*\* |
| 25 | 39 | [Combination Sum    ](https://leetcode.com/problems/combination-sum) | \*\*\* |
| 26 | 98 | [Validate Binary Search Tree    ](https://leetcode.com/problems/validate-binary-search-tree) | \*\*\* |
| 27 | 78 | [Subsets    ](https://leetcode.com/problems/subsets) | \*\*\* |
| 28 | 621 | [Task Scheduler    ](https://leetcode.com/problems/task-scheduler) | \*\*\* |
| 29 | 48 | [Rotate Image    ](https://leetcode.com/problems/rotate-image) | \*\*\* |
| 30 | 152 | [Maximum Product Subarray    ](https://leetcode.com/problems/maximum-product-subarray) | \*\*\* |
| 31 | 236 | [Lowest Common Ancestor of a Binary Tree    ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree) | \*\*\* |
| 32 | 207 | [Course Schedule    ](https://leetcode.com/problems/course-schedule) | \*\*\* |
| 33 | 64 | [Minimum Path Sum    ](https://leetcode.com/problems/minimum-path-sum) | \*\*\* |
| 34 | 240 | [Search a 2D Matrix II    ](https://leetcode.com/problems/search-a-2d-matrix-ii) | \*\*\* |
| 35 | 300 | [Longest Increasing Subsequence    ](https://leetcode.com/problems/longest-increasing-subsequence) | \*\*\* |
| 36 | 438 | [Find All Anagrams in a String    ](https://leetcode.com/problems/find-all-anagrams-in-a-string) | \*\*\* |
| 37 | 34 | [Find First and Last Position of Element in Sorted Array    ](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array) | \*\*\* |
| 38 | 148 | [Sort List    ](https://leetcode.com/problems/sort-list) | \*\*\* |
| 39 | 102 | [Binary Tree Level Order Traversal    ](https://leetcode.com/problems/binary-tree-level-order-traversal) | \*\* |
| 40 | 75 | [Sort Colors    ](https://leetcode.com/problems/sort-colors) | \*\* |
| 41 | 739 | [Daily Temperatures    ](https://leetcode.com/problems/daily-temperatures) | \*\* |
| 42 | 647 | [Palindromic Substrings    ](https://leetcode.com/problems/palindromic-substrings) | \*\* |
| 43 | 96 | [Unique Binary Search Trees    ](https://leetcode.com/problems/unique-binary-search-trees) | \*\* |
| 44 | 105 | [Construct Binary Tree from Preorder and Inorder Traversal    ](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal) | \*\* |
| 45 | 208 | [Implement Trie \(Prefix Tree\)    ](https://leetcode.com/problems/implement-trie-prefix-tree) | \*\* |
| 46 | 309 | [Best Time to Buy and Sell Stock with Cooldown    ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown) | \*\* |
| 47 | 19 | [Remove Nth Node From End of List    ](https://leetcode.com/problems/remove-nth-node-from-end-of-list) | \*\* |
| 48 | 94 | [Binary Tree Inorder Traversal    ](https://leetcode.com/problems/binary-tree-inorder-traversal) | \*\* |
| 49 | 287 | [Find the Duplicate Number    ](https://leetcode.com/problems/find-the-duplicate-number) | \*\* |
| 50 | 416 | [Partition Equal Subset Sum    ](https://leetcode.com/problems/partition-equal-subset-sum) | \*\* |
| 51 | 55 | [Jump Game    ](https://leetcode.com/problems/jump-game) | \*\* |
| 52 | 62 | [Unique Paths    ](https://leetcode.com/problems/unique-paths) | \*\* |
| 53 | 406 | [Queue Reconstruction by Height    ](https://leetcode.com/problems/queue-reconstruction-by-height) | \*\* |
| 54 | 114 | [Flatten Binary Tree to Linked List    ](https://leetcode.com/problems/flatten-binary-tree-to-linked-list) | \*\* |
| 55 | 399 | [Evaluate Division    ](https://leetcode.com/problems/evaluate-division) | \*\* |
| 56 | 279 | [Perfect Squares    ](https://leetcode.com/problems/perfect-squares) | \*\* |
| 57 | 142 | [Linked List Cycle II    ](https://leetcode.com/problems/linked-list-cycle-ii) | \* |
| 58 | 338 | [Counting Bits    ](https://leetcode.com/problems/counting-bits) | \* |
| 59 | 494 | [Target Sum    ](https://leetcode.com/problems/target-sum) | \* |
| 60 | 337 | [House Robber III    ](https://leetcode.com/problems/house-robber-iii) | \* |

## [1. Add Two Numbers](https://leetcode.com/problems/add-two-numbers)

{% tabs %}
{% tab title="Qstn" %}
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example:**

```text
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
{% endtab %}

{% tab title="Video" %}


{% embed url="https://www.youtube.com/watch?v=esZdwGfG7NE" caption="" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*
Sol1: [BEST] Since 'list1' & 'list2' are already in reverseOrder. It is easy to do addition

  |      |      |
  V      V      V
342     342     342
465     465     465
----    ----    ----
  7      07     807
----    ----    ----

  2 ----> 4 ----> 3
  5 ----> 6 ----> 4
 --------------------
  7 ----> 0 ----> 8
 --------------------


Time complexity : O(max(m,n))   // m: l1.length and n: l2.length
Space complexity : O(max(m,n))  // resultList.length
if we dont consider, 'resultList' Space // Space complexity : O(1)
*/
function addTwoNumbers(l1, l2) {
  let resultList = new ListNode(0); // dummyNode
  let resIter = resultList; // 'resultList' iterator

  let p = l1; // 'l1' iterator
  let q = l2; // 'l2' iterator

  let carryFwd = 0;

  while (p !== null || q !== null || carryFwd !== 0) {
    let totalSum = 0;

    if (p !== null) {
      totalSum = totalSum + p.val;
      p = p.next; // next: iter
    }
    if (q !== null) {
      totalSum = totalSum + q.val;
      q = q.next; // next: iter
    }
    totalSum = totalSum + carryFwd;

    // totalSumLastDigit:
    const totalSumLastDigit = totalSum % 10;
    resIter.next = new ListNode(totalSumLastDigit);

    // totalSumExcludeLastDigit:
    carryFwd = Math.floor(totalSum / 10);

    resIter = resIter.next; // next: iter
  }

  // ignore: dummyNode
  return resultList.next;
}
```
{% endtab %}
{% endtabs %}



## 2. LRU

{% tabs %}
{% tab title="Qstn" %}
Design and implement a data structure for [Least Recently Used \(LRU\) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU).

* It should support the following operations: `get` and `put` in **`O(1) time`**
* `get(key)` - get the value by key \(if not exists return -1\) 
  * whenever get\(key\) happens, consider that particular item is _**recently used**_
* `put(key, val)` - add/update the key and value 
  * when the cache reached its max capacity, it should remove Least Recently Used item
  * and add the new item
{% endtab %}

{% tab title="Video" %}


{% embed url="https://www.youtube.com/watch?v=S6IfqDXWa10" caption="" %}





**Solution: `HashMap` + `DoublyLinkedList`**

* `HM`: for quick access // **get**, add, remove in O\(1\) time 
* `DLL`: for maintaining the 'recentlyUsedItems' order // **reArrange**, add, remove in O\(1\) time 

**TimeComplexity**: O\(1\) both for put and get. **SpaceComplexity** : O\(capacity\)

```java

```
{% endtab %}

{% tab title="Sol" %}
```java
LRUCache obj = new LRUCache(5);
obj.put(1, 11);
// addNewItem
// DLL: H--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1 }

obj.put(2, 22);
// addNewItem
// DLL: H--> <--[prev]DLNode2[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2 }


obj.put(3, 33);
// addNewItem
// DLL: H--> <--[prev]DLNode3[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3 }


obj.get(2); // 22
// updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3 }


obj.put(1, 111);
// updateExistingItemVal & updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--T
// HM: { 1: **DLNode1**, 2: DLNode2, 3: DLNode3 }


obj.put(4, 44);
// addNewItem
// DLL: H--> <--[prev]DLNode4[next]--><--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3, 4: DLNode4 }



obj.put(5, 55);
// addNewItem
// DLL: H--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--[prev]DLNode3[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 3: DLNode3, 4: DLNode4, 5: DLNode5 }


obj.put(6, 66);
// addNewItem, removedLeastRecentlyUsedItem (DLL's lastItem - DLNode3)
// DLL: H--> <--[prev]DLNode6[next]--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--[prev]DLNode1[next]--> <--[prev]DLNode2[next]--> <--T
// HM: { 1: DLNode1, 2: DLNode2, 4: DLNode4, 5: DLNode5, 6: DLNode6 }



obj.put(7, 77);
// addNewItem, removedLeastRecentlyUsedItem (DLL's lastItem - DLNode3)
// DLL: H--> <--[prev]DLNode7[next]--> <--[prev]DLNode6[next]--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--[prev]DLNode1[next]--> <--T
// HM: { 1: DLNode1, 4: DLNode4, 5: DLNode5, 6: DLNode6, 7: DLNode7 }



obj.get(1);
// updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode1[next]--> <--[prev]DLNode7[next]--> <--[prev]DLNode6[next]--> <--[prev]DLNode5[next]--> <--[prev]DLNode4[next]--> <--T
// HM: { 1: DLNode1, 4: DLNode4, 5: DLNode5, 6: DLNode6, 7: DLNode7 }



obj.put(5, 555);
// updateExistingItemVal & updateRecentlyUsedItemToFront
// DLL: H--> <--[prev]DLNode5[next]--> <--[prev]DLNode1[next]--> <--[prev]DLNode7[next]--> <--[prev]DLNode6[next]--> <--[prev]DLNode4[next]--> <--T
// HM: { 1: DLNode1, 4: DLNode4, 5: **DLNode5**, 6: DLNode6, 7: DLNode7 }
```

```java
class LRUCache {

    /* ------------------------ Doubly Linked List  ------------------------ */

    private DLLNode head, tail;

    private class DLLNode {
        int key;
        int value;
        DLLNode prev;
        DLLNode next;
    }

    /*
      insert: 'newNode' into 'HEAD' of the Double Linked List

        ## 1. populate: 'newNode'
           headNode <-- '[prev] newNode [next]' --> previousFirstNode

        ## 2. update: 'headNode.next' and 'previousFirstNode.prev'
           headNode[next] --> 'newNode' <-- previousFirstNode[prev]
    */
    private void addNode(DLLNode newNode){
        DLLNode previousFirstNode = head.next;

        // ## 1. populate: 'newNode'
        newNode.prev = head;
        newNode.next = previousFirstNode;

        // ## 2. update: 'headNode.next' and 'previousFirstNode.prev'
        head.next = newNode;
        previousFirstNode.prev = newNode; // previousFirstNode.prev = newNode
    }

    /*
      remove: 'targetNode' from Double Linked List

      ## 1. get: 'targetNodePrevNode' & 'targetNodeNextNode'
          targetNodePrevNode <-- [prev] targetNode [next] --> targetNodeNextNode

      ## 2. populate: 'targetNodePrevNode.next' & 'targetNodeNextNode.prev'
          targetNodePrevNode[next] --> targetNodeNextNode
          targetNodePrevNode <-- [prev] targetNodeNextNode

    */
    private void removeNode(DLLNode targetNode){

        // ## 1. get: 'targetNodePrevNode' & 'targetNodeNextNode'
        DLLNode targetNodePrevNode = targetNode.prev;
        DLLNode targetNodeNextNode = targetNode.next;

        // ## 2. populate: 'targetNodePrevNode.next' & 'targetNodeNextNode.prev'
        targetNodePrevNode.next = targetNodeNextNode;
        targetNodeNextNode.prev = targetNodePrevNode;
    }

    /*
      Move a node to the head of the doubly linked lsit
       1. remove the targetNode from doubly linked lsit
       1. add the targetNode to starting position of doubly linked lsit
    */
    private void moveToHead(DLLNode node){
        removeNode(node);
        addNode(node);
    }

    /*
      Pop the last item from the structure
    */
    private DLLNode popTail(){
        DLLNode lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }


    /* ------------------------ / Doubly Linked List  ------------------------ */

    private Map<Integer, DLLNode> hashMap = new HashMap<>();

    private int totalItemsInCache;
    private int maxCapacity;

    public LRUCache(int maxCapacity) {

        // Cache starts empty and capacity is set by client
        totalItemsInCache = 0;
        this.maxCapacity = maxCapacity;

        // Initialize the dummy head of the hashMap
        head = new DLLNode();
        head.prev = null;

        // Init the dummy tail of the hashMap
        tail = new DLLNode();
        tail.next = null;

        // Wire the head and tail together
        head.next = tail;
        tail.prev = head;
    }

    /*
      Retrieve an item from the hashMap
    */
    public int get(int key) {
        DLLNode node = hashMap.get(key);

        if (node == null) {
            // targetItem not available
            return -1;
        } else {
            // targetItem available
            // targetItem has been accessed,  move: 'targetItem' to the front of the Linked List.
            moveToHead(node);
            return node.value;
        }
    }

    /*
      addItem or updateItem
      addItem: add + ifApplicableRemoveLRU
      updateItem: updateVal + updateRecentlyUsedItem
    */
    public void put(int key, int value) {

        DLLNode node = hashMap.get(key);
        if (node == null) {
            // targetItem not available,
            //  1. add the 'newEntry' in the Map
            //  2. add the 'newNode' in the DLL
            //  3. check: whether we have reached the maxCapacity
            //      if: yes --> remove the (DLL's lastItem) from DLL and Map as 'LRU eviction policy'

            // populate: newNode
            DLLNode newNode = new DLLNode();
            newNode.key = key;
            newNode.value = value;

            // 1. add the 'newEntry' in the Map
            hashMap.put(key, newNode);
            // 2. add the 'newNode' in the DLL
            addNode(newNode);


            // 3. check: whether we have reached the maxCapacity
            totalItemsInCache++; // we just added an item to the hashMap & DLL

            // If over capacity evict an item with LRU eviction policy
            if(totalItemsInCache > maxCapacity){
                removeLRUEntryFromStructure();
            }

        } else {
            // targetItem available,
            // 1. update: the 'targetItem' with new value
            // 2. targetItem has been accessed,  move: 'targetItem' to the front of the Linked List.
            node.value = value;
            moveToHead(node);
        }

    }

    /*
      remove the (DLL's lastItem) from DLL and Map as per 'LRU eviction policy'
    */
    private void removeLRUEntryFromStructure() {
        DLLNode tail = popTail();
        hashMap.remove(tail.key);
        --totalItemsInCache;
    }


}
```

```java
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;

    public LRUCache(int capacity) {
        // LinkedHashMap
        // arg1: capacity, arg2: loadFactor, arg3: isAccessOrder
        // arg3: "false" for insertion-order (default), "true" for access-order 
        super(capacity, 0.75F, true);

        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
{% endtab %}
{% endtabs %}



## [3. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring)

{% tabs %}
{% tab title="Video" %}
1. [https://www.youtube.com/watch?v=onkdOAMS63U](https://www.youtube.com/watch?v=onkdOAMS63U)

**DP:** Time: O\(n\), Space: O\(n^2\)

1. [https://www.youtube.com/watch?v=obBdxeCx\_Qs](https://www.youtube.com/watch?v=obBdxeCx_Qs)
2. [https://www.youtube.com/watch?v=Fi5INvcmDos](https://www.youtube.com/watch?v=Fi5INvcmDos)

\*\*\*\*

**Expand Around Center Alg:** Time: O\(n^2\), Space: O\(1\)

**Manchester's Alg:** Time: O\(n\), Space: O\(n\) `[BEST]`

1. [https://www.youtube.com/watch?v=SV1ZaKCozS4](https://www.youtube.com/watch?v=SV1ZaKCozS4) \[BEST\]
2. [https://www.youtube.com/watch?v=kbUiR5YWUpQ](https://www.youtube.com/watch?v=kbUiR5YWUpQ)
3. [https://www.youtube.com/watch?v=nbTSfrEfo6M](https://www.youtube.com/watch?v=nbTSfrEfo6M)
4. [http://manacher-viz.s3-website-us-east-1.amazonaws.com/\#/](http://manacher-viz.s3-website-us-east-1.amazonaws.com/#/)
{% endtab %}

{% tab title="Sol: \[EASY\]" %}
```javascript
/*
Using: 'Expand Around Center' approach [ JAG ]

// This is better for interview

// Time complexity : O(n^2) // Space complexity : O(1)
*/
function longestPalindrome(s) {
  if (s === null || s.length < 1) return "";
  let startIndex = 0;
  let endIndex = 0;

  let maxPalin = { length: 0 };

  for (let i = 0; i < s.length; i++) {
    let oddPalind = expandAroundCenter(s, i, i);
    let evenPalind = expandAroundCenter(s, i, i + 1);

    // currPalin: max(oddPalindLen, evenPalindLen)
    let currPalin =
      oddPalind.length > evenPalind.length ? oddPalind : evenPalind;

    // update: maxPalin
    maxPalin = currPalin.length > maxPalin.length ? currPalin : maxPalin;
  }
  return s.slice(maxPalin.start, maxPalin.end + 1);
}

function expandAroundCenter(s, left, right) {
  while (s[left] && s[right] && s[left] === s[right]) {
    left--;
    right++;
  }

  const start = left + 1;
  const end = right - 1;
  const length = end - start <= 0 ? 0 : end - start + 1;
  return { start, end, length };
}
```
{% endtab %}

{% tab title="Sol: \[BEST\]" %}
```javascript
/*
Using: Manacher algorithm  
// (This is NOT better for interview, becoz nobody get this solution in 40min interview)

// Time complexity : O(n) // Space complexity : O(n)
*/
function longestPalindrome(s) {
  let T = "$#" + s.split("").join("#") + "#@";
  // palindrome: for eachChar 
  let P = Array(T.length).fill(0);
  let center = 0;
  let right = 0;

  for (let i = 0; i < T.length; i++) {
    let mirr = 2 * center - i;

    // 1. if: 'currIndex' is within the 'rightBoundary'
    // then: try to use the palidrome 'mirror' value
    if (i < right) P[i] = Math.min(right - i, P[mirr]);

    // 2. expand:
    while (T[i + (1 + P[i])] === T[i - (1 + P[i])]) P[i]++;

    // 3. Is 'currPalindromeRightBoundary' is greater than 'rightBoundary'
    // then: update the 'center' and 'rightBoundary'
    if (i + P[i] > right) {
      center = i;
      right = i + P[i];
    }
  }

  let maxlength = 0; // length of longest palindromic substring
  let maxCenter = 0; // center of longest palindromic substring
  for (let i = 0; i < P.length; i++) {
    if (P[i] > maxlength) {
      maxlength = P[i];
      maxCenter = i;
    }
  }

  return s.substring(
    (maxCenter - 1 - maxlength) / 2,
    (maxCenter - 1 + maxlength) / 2
  );
}
```
{% endtab %}

{% tab title="Sol: \[dp\]" %}
```javascript
/*
 Use: dpTable -to store the previous computations
 // (This is NOT better for interview, becoz it is complex and consider 'expandAroundCenter' approach with same timeComplexity)

 // Time complexity : O(n^2) // Space complexity : O(n^2)
*/
function lps(s) {
  let n = s.length;
  let palindromeBeginsAt = 0; //index where the longest dpTable begins
  let maxSubStrLenSoFar = 1; //length of the longest dpTable
  let dpTable = []; //boolean table to store dpTable truth

  // Populate: 'dpTable' // In this process, also update the max(maxSubStrLenSoFar)

  // 1. Base Case: ‘1 char substring’ - is always ‘palindrome’
  for (let i = 0; i < n; i++) {
    dpTable[i][i] = true;
  }

  // 2. Base Case: if: '2 char substring' - Is 'first and last char same' - then it is a 'dpTable'
  for (let i = 0; i < n - 1; i++) {
    const first = s[i];
    const last = s[i + 1];
    if (first === last) {
      dpTable[i][i + 1] = true;
      palindromeBeginsAt = i;
      maxSubStrLenSoFar = 2;
    }
  }

  // 3. if: ‘3+ char substring’
  // - [3.1] Is ‘first and last char same’ and [3.2] Is ‘middleSubStr palidrome (check: fromAlreadyComputed-DP)’
  // - then it is a ‘palindrome’

  // for: (3 to n) - to find the comibinations of substr
  for (let currSubStrLen = 3; currSubStrLen <= n; currSubStrLen++) {

    // populate: 'substr' for 'currSubStr'
    const substrEndIndex = n - currSubStrLen + 1;
    for (let i = 0; i < substrEndIndex; i++) {
      let firstCharIndex = i;
      let lastCharIndex = i + currSubStrLen - 1;

      // 3.1 Is 'first' & 'last' char of currSubStr 'Same' ?
      let isFirstAndLastCharSame = s[firstCharIndex] === s[lastCharIndex];
      // 3.2 Is ‘middleSubStr palidrome (check: fromAlreadyComputed-dpTable)
      let isMiddleSubStrPalindrome = dpTable[firstCharIndex + 1][lastCharIndex - 1];

      if (isFirstAndLastCharSame && isMiddleSubStrPalindrome) {
        // store: currSubStr is Palindrome
        dpTable[firstCharIndex][lastCharIndex] = true;
        palindromeBeginsAt = firstCharIndex;
        maxSubStrLenSoFar = currSubStrLen;
      }
    }
  }
  return s.slice(palindromeBeginsAt, maxSubStrLenSoFar + palindromeBeginsAt);
}
```
{% endtab %}
{% endtabs %}

## [4. Number of Islands](https://leetcode.com/problems/number-of-islands)

{% tabs %}
{% tab title="Qstn" %}
**200. Number of Islands**

Given a 2d grid map of `'1'`s \(land\) and `'0'`s \(water\), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```text
Input:
11110
11010
11000
00000

Output: 1
```

**Example 2:**

```text
Input:
11000
11000
00100
00011

Output: 3
```
{% endtab %}

{% tab title="Video" %}


{% embed url="https://www.youtube.com/watch?v=CGMNePwovA0" caption="" %}
{% endtab %}

{% tab title="Sol" %}
```javascript
/*
 Using: DFS

 Linear scan the 2d grid map, 
  - if a node contains a '1', then it is a root node that triggers a Depth First Search. 
  - During DFS, every visited node should be set as '0' to mark as visited node. 
  - Count the number of root nodes that trigger DFS, 
      - this number would be the number of islands since each DFS starting at some root identifies an island.

Steps:
  // 1. found a land // currNode is '1'
  // 2. try 'DFS' to see whether we can acquire nearby land
        // 2.1 (not-acquired) land found
            - acquire it:  by marking currNode as '0' (visited/acquired/markItUnAvailableForNextTime)
        // 2.2 go all direction and try 'DFS' to see whether we can acquire nearby land

 // Time complexity : O(n^2) // Space complexity : O(n^2)


 Time complexity : O(M×N) where M is the number of rows and N is the number of columns.
 Space complexity : worst case O(M×N) in case that the grid map is filled with lands where DFS goes by NM×N deep.
*/

// [JAG]
function dfs(grid, r, c) {
  // base-case:
  // currNode: shouldBeWithinBoundary & shouldNotBeZero
  if (!grid[r] || !grid[r][c] || grid[r][c] === "0") return;

  // 2.1 (not-acquired) land found
  // acquire it:  by marking currNode as '0' (visited/acquired/markItUnAvailableForNextTime)
  grid[r][c] = "0";

  // 2.2 go all direction and try 'DFS' to see whether we can acquire nearby land
  dfs(grid, r - 1, c);
  dfs(grid, r + 1, c);
  dfs(grid, r, c - 1);
  dfs(grid, r, c + 1);
}

function numIslands(grid) {
  if (!grid || !grid.length) return 0;

  let count = 0;
  const nr = grid.length; // noOfRow
  const nc = grid[0].length; // noOfCols

  for (let r = 0; r < nr; r++) {
    for (let c = 0; c < nc; c++) {
      if (grid[r][c] === "1") {
        // 1. found a land // currNode is '1'
        count = count + 1;

        // 2. try 'DFS' to see whether we can acquire nearby land
        dfs(grid, r, c);
      }
    }
  }
  return count;
}

const grid1 = [
  ["1", "1", "1", "1", "0"],
  ["1", "1", "0", "1", "0"],
  ["1", "1", "0", "0", "0"],
  ["0", "0", "0", "0", "0"]
];
console.log(numIslands(grid1)); // 1
```
{% endtab %}
{% endtabs %}

\*\*\*\*

## [5. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters)

{% tabs %}
{% tab title="Video" %}
* [https://www.youtube.com/watch?v=aIrbWbON63M](https://www.youtube.com/watch?v=aIrbWbON63M)
* [https://www.youtube.com/watch?v=8ZlmgBcQzMM](https://www.youtube.com/watch?v=8ZlmgBcQzMM)
{% endtab %}

{% tab title="Code" %}
```javascript
/*
Using 'Sliding Window' (Set and Two Pointer)

// Time complexity : O(2n) = O(n) // In the worst case each character will be visited twice by i and j.
// Space complexity : O(min(m, n))  // size of the charset 'm' or size of the string 'n' // whichever is minimum
*/
function lengthOfLongestSubstring(s) {
  let maxSofar = 0;
  const charSet = new Set();

  // leftPtr & rightPtr
  let l = 0,
    r = 0;
  while (l < s.length && r < s.length) {
    const currChar = s[r];

    if (!charSet.has(currChar)) {
      // itemNotFoundInSet: consider 'currChar' as part of prevSubStr

      // add: currChar in Set
      charSet.add(currChar);

      // eval: maxSubStrLen
      const currSubStrLen = r - l + 1; // subStrlen = endIndex - startIndex + 1 // formula
      maxSofar = Math.max(maxSofar, currSubStrLen);

      // move 'rightPtr' to 'nextItem'
      r++;
    } else {
      // itemFoundInSet: delete the leftPtrItem from Set
      charSet.delete(s[l]);

      // move 'leftPtr' to 'nextItem'
      l++;
    }
  }
  return maxSofar;
}
```
{% endtab %}

{% tab title="Sol2: \[BEST\]" %}
```javascript
/*
Using 'Sliding Window (Improved)' (Map and Two Pointer) [BEST]

// Time complexity : O(n) 
// Space complexity : O(min(m, n))  // size of the charset 'm' or size of the string 'n' // whichever is minimum
*/
function lengthOfLongestSubstring(s) {
  if (s.length == 0) return 0;
  let maxSofar = 0;

  // { eachChar: index }
  const charMap = new Map();

  // leftPtr & rightPtr
  let l = 0,
    r = 0;
  while (r < s.length) {
    const currChar = s[r];

    if (charMap.has(currChar)) {
      // itemFoundInSet: jump the 'leftPtr' to existingCharIndex and move 'leftPtr' to 'nextItem'
      // whichever is greater consider that as 'leftPtr'
      l = Math.max(l, charMap.get(currChar) + 1);
    }

    // add: currChar in Set
    charMap.set(currChar, r);

    // eval: maxSubStrLen
    const currSubStrLen = r - l + 1; // subStrlen = endIndex - startIndex + 1 // formula
    maxSofar = Math.max(maxSofar, currSubStrLen);

    // move 'rightPtr' to 'nextItem'
    r++;
  }

  return maxSofar;
}
```
{% endtab %}
{% endtabs %}

## [6. 3Sum](https://leetcode.com/problems/3sum)

{% tabs %}
{% tab title="Question" %}
**15. 3Sum**

Given an array `nums` of _n_ integers, are there elements _a_, _b_, _c_ in `nums` such that _a_ + _b_ + _c_ = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:**

The solution set must not contain duplicate triplets.

**Example:**

```text
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
{% endtab %}

{% tab title="Video" %}
* [https://www.youtube.com/watch?v=jXZDUdHRbhY](https://www.youtube.com/watch?v=jXZDUdHRbhY)
* [https://www.youtube.com/watch?v=X5UhF3xS5Dk](https://www.youtube.com/watch?v=X5UhF3xS5Dk)
* [https://www.youtube.com/watch?v=-AMHUdZc9ss](https://www.youtube.com/watch?v=-AMHUdZc9ss)
{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}



## [7. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)

{% tabs %}
{% tab title="Question" %}
**238. Product of Array Except Self**

-or- Multiply all fields except its position in an array

```javascript
Example 1:
----------
Input:  [1,2,3,4] ==> Output: [24,12,8,6]

// '#exceptSelf#'
index:0 --> 1 --> 2*3*4=24     // [#1#,2,3,4]
index:1 --> 2 --> 1*3*4=12     // [1,#2#,3,4]
index:2 --> 3 --> 1*2*4=8      // [1,2,#3#,4]
index:3 --> 4 --> 1*2*3=6      // [1,2,3,#4#]


Example 2:
----------
Input:  [4,2,1,7] ==> Output: [14,28,56,8]
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=61IjpElFcn8" %}

{% embed url="https://www.youtube.com/watch?v=vB-81TB6GUc" %}
{% endtab %}

{% tab title="Code" %}
```javascript

/*
  (skip current) and multiply from 'left' and (skip current) and multiply from 'right' approach
  TC: O(n) SC: O(1)
*/
function productExceptSelf(nums) {
  const output = [1];

  // 1.(skip current) and multiply from 'left' 
  let leftVal = 1;
  for (let i = 1; i < nums.length; i++) {
    const prevItem = nums[i - 1];
    leftVal = leftVal * prevItem;
    output.push(leftVal);
  }


  // 2.(skip current) and multiply from 'right' 
  let rightVal = 1;
  for (let i = nums.length - 2; i >= 0; i--) {
    const prevItem = nums[i + 1];
    rightVal = rightVal * prevItem;

    output[i] = output[i] * rightVal;
  }

  return output;
}
```
{% endtab %}

{% tab title="Explanation" %}
```javascript
/*
Input:
 ---------------
| 1 | 2 | 3 | 4 |
 ---------------

// 1.(skip current#) and multiply from 'left' 

     ---------------
    | #1 | . | . | . |
    -----------------                 ----------------
targetIndex: '0' ==> left = 1 ==>    | *1 |   |   |   | 
                                      ----------------
     ----------------
    | 1 | #2 | . | . |
     ----------------                 ----------------
targetIndex: '1' ==> left = 1 ==>    | 1 | *1 |   |   | 
                                      ----------------
     ----------------
    | 1 | 2 | #3 | . |
     ----------------                 ----------------
targetIndex: '2' ==> left = 2 ==>    | 1 | 1 | *2 |   | 
                                      -----------------
     ----------------
    | 1 | 2 | 3 | #4 |
     ----------------                 ----------------
targetIndex: '3' ==> left = 6 ==>    | 1 | 1 | 2 | *6 | 
                                      ----------------


// 2.(skip current#) and multiply from 'right' 

     ----------------
    | . | . | . | #4 |
     ----------------                          ----------------
targetIndex: '3' ==> 'right=1' ==> 1*6 ==>    | 1 | 1 | 2 | *6 | 
                                               ----------------

     ----------------
    | . | . | #3 | 4 |
     ----------------                          ----------------
targetIndex: '2' ==> 'right=4' ==> 4*2 ==>    | 1 | 1 | *8 | 6 | 
                                               ----------------

     ----------------
    | . | #2 | 3 | 4 |
     ----------------                            ----------------
targetIndex: '1' ==> 'right=12' ==> 12*1 ==>    | 1 | *12 | 8 | 6 | 
                                                 ----------------

     ----------------
    | #1 | 2 | 3 | 4 |
     ----------------                            ----------------
targetIndex: '0' ==> 'right=24' ==> 24*1 ==>    | *24 | 12 | 8 | 6 | 
                                                 ----------------

Output:
 -----------------
| 24 | 12 | 8 | 6 | 
 -----------------

Input:
 ---------------
| 1 | 2 | 3 | 4 |
 ---------------

*/



/*
Input:
 ---------------
| 4 | 2 | 1 | 7 |
 ---------------

// 1.(skip current#) and multiply from 'left' 

     ---------------
    | #4 | . | . | . |
    -----------------                 ----------------
targetIndex: '0' ==> left = 1 ==>    | *1 |   |   |   | 
                                      ----------------
     ----------------
    | 4 | #2 | . | . |
     ----------------                 ----------------
targetIndex: '1' ==> left = 4 ==>    | 1 | *4 |   |   | 
                                      ----------------
     ----------------
    | 4 | 2 | #1 | . |
     ----------------                 ----------------
targetIndex: '2' ==> left = 8 ==>    | 1 | 4 | *8 |   | 
                                      -----------------
     ----------------
    | 4 | 2 | 1 | #7 |
     ----------------                 ----------------
targetIndex: '3' ==> left = 8 ==>    | 1 | 4 | 8 | *8 | 
                                      ----------------


// 2.(skip current#) and multiply from 'right' 

     ----------------
    | . | . | . | #7 |
     ----------------                          ----------------
targetIndex: '3' ==> 'right=1' ==> 1*6 ==>    | 1 | 4 | 8 | *8 | 
                                               ----------------

     ----------------
    | . | . | #1 | 7 |
     ----------------                          -----------------
targetIndex: '2' ==> 'right=7' ==> 7*8 ==>    | 1 | 4 | *56 | 8 | 
                                               -----------------

     ----------------
    | . | #2 | 1 | 7 |
     ----------------                          ------------------
targetIndex: '1' ==> 'right=7' ==> 7*4 ==>    | 1 | *28 | 56 | 8 | 
                                               ------------------

     ----------------
    | #4 | 2 | 1 | 7 |
     ----------------                            -------------------
targetIndex: '0' ==> 'right=14' ==> 14*1 ==>    | *14 | 28 | 56 | 8 | 
                                                 -------------------

Output:
 -----------------
| 14 | 28 | 56 | 8 | 
 -----------------

Input:
 ---------------
| 4 | 2 | 1 | 7 |
 ---------------

*/
```
{% endtab %}
{% endtabs %}

## [8. Merge Intervals](https://leetcode.com/problems/merge-intervals)

{% tabs %}
{% tab title="Question" %}
56. Merge Intervals  // Given a collection of intervals, merge all overlapping intervals.

```javascript
Example 1:
----------
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]

Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

Example 2:
-----------
Input: [[1,4],[4,5]]
Output: [[1,5]]
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=Z52tWkco7BM" %}

{% embed url="https://www.youtube.com/watch?v=NWQp0IFRPi4" %}
{% endtab %}

{% tab title="Code" %}
```javascript

/*
[Optimal]: Sort the Input, and find the overlap
// check: isNextInterval overlap 'lastResultInterval'
TC: O(n logn) SC: O(1)
*/
function merge(intervals) {
  if (intervals && intervals.length === 0) {
    return intervals;
  }

  const sortedIntervals = intervals.sort((a, b) => a[0] - b[0]);

  const result = [sortedIntervals[0]];

  for (let i = 1, len = sortedIntervals.length; i < len; i++) {
    const lastResultInt = result[result.length - 1];
    const nextInterval = sortedIntervals[i];

    // check: isNextInterval overlap 'lastResultInterval'
    if (nextInterval[0] <= lastResultInt[1]) {
    
      // mergeIntervals: (move the nextIntervalEnd if only needed)
      if (nextInterval[1] > lastResultInt[1]) {
        // nextIntervalEnd goes beyond lastResultIntEnd (update: lastResultIntEnd as nextIntervalEnd)
        lastResultInt[1] = nextInterval[1];
      }
      
    } else {
      // no overlap
      result.push(nextInterval);
    }
  }

  return result;
}
```
{% endtab %}
{% endtabs %}

## [9. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array)

{% tabs %}
{% tab title="Question" %}
33. Search in Rotated Sorted Array
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=uufaK2uLnSI" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*
[Linear]: search: eachItem
TC: O(n) SC: O(1)
*/
function search(nums, target) {
  for (let i =0; i<nums.length; i++) {
    if(nums[i] ===target) {
      return i;
    }
  }
}

/* ------------------------------------------------------------
Can we do it better?
 - since, 'inputArr' is Sorted // we should be able to use 'Binary Search'
 - But the 'inputArr' is rotated, so we have to slightly modify 'Binary Search' 
 - and can find targetItem in O(logn)
 ------------------------------------------------------------ */

/*
[Optimal]: Modified Binary Search
TC: O(n logn) SC: O(1)
*/
function search(nums, target) {
  let start = 0,
    end = nums.length - 1;

  while (start <= end) {

    const mid = start + Math.floor((end - start) / 2);

    if (nums[mid] === target) {
      // case1: found target
      return mid;
    }

    // 2. check: Is 'rightArrProperlySorted'?
    if (nums[mid] <= nums[end]) {
      // 2a. check: 'target' can be available in 'rightSortedArr'
      if (nums[mid] < target && target <= nums[end]) {
        // search only in 'rightSortedArr'
        start = mid + 1;
      } else {
        // 2b. 'rightSortedArr' doesnt have target, go search in 'leftArr'
        end = mid - 1;
      }
    }
    // 3. check: Is 'leftArrProperlySorted'?
    // } else if (nums[start] <= nums[mid]) {  // else is also same
    else {
      // 3a. check: 'target' can be available in 'leftSortedArr'
      if (nums[start] <= target && target < nums[mid]) {
        // search only in 'leftSortedArr'
        end = mid - 1;
      } else {
        // 3b. 'leftSortedArr' doesnt have target, go search in 'rightArr'
        start = mid + 1;
      }
    }
  }

  return -1;
}
```
{% endtab %}
{% endtabs %}



## [10. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii)

{% tabs %}
{% tab title="Question" %}
253. Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...]` \(si &lt; ei\), find the minimum number of conference rooms required.

```javascript
Example 1:
-----------
Input: [[0, 30],[5, 10],[15, 20]]
Output: 2

Example 2:
-----------
Input: [[7,10],[2,4]]
Output: 1
```

```javascript
// 1. Sort the intervals by startTime
// 2. keep: track of *all* 'nxtEarliestMeetingEndTime' // Use: 'PriorityQueue'
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=GmpyAMpjpUY&t=319s" %}

{% embed url="https://www.youtube.com/watch?v=g9YK6sftDi0" %}
{% endtab %}

{% tab title="Code" %}
```javascript
// Leetcode Soln:
function minMeetingRooms(intervals) {
  // Check for the base case. If there are no intervals, return 0
  if (intervals.length == 0) {
    return 0;
  }

  // 1. Sort the intervals by startTime
  intervals = intervals.sort((a, b) => a[0] - b[0]);

  // 2. keep: track of *all* 'nxtEarliestMeetingEndTime'
  // Use a min heap to track the minimum end time of merged intervals
  const heap = new PriorityQueue((a, b) => a < b);

  // Add the first meeting (endTime)
  heap.add(intervals[0][1]);

  // Iterate over remaining intervals
  for (let i = 1; i < intervals.length; i++) {
    const curr = intervals[i];
    const currStart = curr[0];
    const currEnd = curr[1];

    // If the room due to free up the earliest is free, assign that room to this meeting.
    const nxtEarliestMeetingEndTime = heap.peek();
    if (currStart >= nxtEarliestMeetingEndTime) {
      heap.poll();
    }

    // If a new room is to be assigned, then also we add to the heap,
    // If an old room is allocated, then also we have to add to the heap with updated end time.
    heap.add(currEnd);
  }

  console.log(heap.items);
  // The size of the heap tells us the minimum rooms required for all the meetings.
  return heap.size();
}
```
{% endtab %}

{% tab title="Explanation" %}
```javascript
/*

Input:
[meetingStartTime, meetingEndTime]
  
[[0, 30],[5, 10],[15, 20], [12,25], [20,25], [0,10], [0,5]]

0                                           30
|--------------------m:A--------------------|

      5       10
      |--m:B---|

                      15      20
                      |--m:C---|

                  12                 25
                  |--------m:D--------|

                                20       25
                                |---m:E---|

0              10
|-----m:F------|

0     5
|-m:G-|


// 1. Sort the intervals by startTime

0                                           30
|--------------------m:A--------------------|

0             10
|-----m:F------|

0     5
|-m:G-|

      5       10
      |--m:B---|

                  12                 25
                  |--------m:D--------|

                    15      20
                    |--m:C---|

                             20       25
                             |---m:E---|



// 2. keep: track of *all* 'nxtEarliestMeetingEndTime'


0) m:A --> r:1 alloted  --> update: nxtEarliestMeetingEndTime= 30

// can we reuse the same room (startTime: 0)? No  // becoz: nxtEarliestMeetingEndTime= 30
1) m:F --> r:2 alloted  --> update: nxtEarliestMeetingEndTime=10  // [10, 30]

// can we reuse the same room (startTime: 0)? No  // becoz: nxtEarliestMeetingEndTime= 10
2) m:G --> r:3 alloted  ==> update: nxtEarliestMeetingEndTime=5   // [5, 10, 30]

// can we reuse the same room (startTime: 5)? Yes  // becoz: 'nxtEarliestMeetingEndTime=5' and 'startTime=5'
3) m:B --> r:3 alloted  ==> update: nxtEarliestMeetingEndTime=10  // [10, 10, 30]

// can we reuse the same room (startTime: 12)? Yes  // becoz: 'nxtEarliestMeetingEndTime=10' and 'startTime=12'
4) m:D --> r:3 alloted  ==> update: nxtEarliestMeetingEndTime=10   // [10, 25, 30]

// can we reuse the same room (startTime: 15)? Yes  // becoz: 'nxtEarliestMeetingEndTime=10' and 'startTime=15'
5) m:C --> r:2 alloted  ==> update: nxtEarliestMeetingEndTime=20   // [20, 25, 30]


// can we reuse the same room (startTime: 20)? Yes  // becoz: 'nxtEarliestMeetingEndTime=20' and 'startTime=20'
6) m:E --> r:2 alloted  ==> update: nxtEarliestMeetingEndTime=25   // [25, 25, 30]


r:1
0                                           30
|--------------------m:A--------------------|

r:2
0             10     15       20         25
|-----m:F------|     |--m:C---||---m:E---|

r:3
0      5        10 12                  25
|-m:G-||--m:B---|  |--------m:D--------|


No of Rooms Required: 3
                   
*/
```
{% endtab %}
{% endtabs %}

## [11. Group Anagrams](https://leetcode.com/problems/group-anagrams)

{% tabs %}
{% tab title="Question" %}
Given an array of strings, group anagrams together.

```javascript
Example 1:
-----------
Input: ["eat", "tea", "tan", "ate", "nat", "bat"]

Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=C6cSD-PZOjw" %}
{% endtab %}

{% tab title="Sol1" %}
```javascript
/*
  Using: Sorting

  Time Complexity: O(N KlogK)  // k: string max length // sorting the str takes KLogk
  Space Complexity: O(NK)

  i/p: ["eat", "tea", "tan", "ate", "nat", "bat"]
  sortedStrMap: 
  {
      'aet': ['eat', 'tea', 'ate'],
      'ant': ['nat'],
      'abt': ['bat']
  }

*/
function groupAnagrams(strs) {
  const map = {};

  for (let str of strs) {
    const key = [...str].sort().join("");

    if (map[key]) {
      map[key].push(str);
    } else {
      map[key] = [str];
    }
  }

  return Object.values(map);
}
```
{% endtab %}

{% tab title="Sol2: \[BEST\]" %}
```javascript
// can we optimize this?
// Yes: instead of 'sorting' create 'customHash' 

/* 
   createHash: for each str (without char order) // using 'alphabetIndexCount'
   TC: O(1)  // it executes always '26 times' which is constant time
*/
function createHash(str) {
  const hash = Array(26).fill(0);
  for (let i = 0; i < str.length; i++) {
    // get 'charIndex' starting point from '0' (instead of starting 97 ascii val)
    const charIndex = str.charCodeAt(i) - 97; // -or- str.charCodeAt(i) - 'a'.charCodeAt(0);
    hash[charIndex] = hash[charIndex] + 1;
  }
  return hash.join("");
}

function groupAnagrams(strs) {
  if (strs.length === 0) return [];

  const map = {};
  for (let str of strs) {
    const key = createHash(str);

    if (map[key]) {
      map[key].push(str);
    } else {
      map[key] = [str];
    }
  }

  return Object.values(map);
}

```
{% endtab %}

{% tab title="Sol2: \[Explanation\]" %}
```javascript
/*
hash:
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ]


createHash: for each str (without char order) // using 'alphabetIndexCount'

hash: ate
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ]

hash: eat
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ]

hash: tea
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ]


hash: nat
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ]


hash: tan
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ]


hash: bat
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
[ 1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0 ]


  {
      '10000000000000000001000000': ['eat', 'tea', 'ate'],
      '10000000000001000001000000': ['nat'],
      '11000000000000000001000000': ['bat']
  }

*
```
{% endtab %}
{% endtabs %}

## [12. Generate Parentheses](https://leetcode.com/problems/generate-parentheses)

{% tabs %}
{% tab title="Question" %}
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Generate all possible valid combinations set \(n=3\)

```text
For example, given n = 3, a solution set is:
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=yNpF3V11aXY" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*

// https://www.youtube.com/watch?v=yNpF3V11aXY

Rules:

2. can i add 'openBracket'?
  - if: open < n (only then we can add 'openBracket')
  - becoz: we cannot add 'openBracket' more than 'n' 

3. can i add 'closeBracket'?
  - if: open > close (only then we can add 'closeBracket')
  - becoz: we cannot add 'closeBracket' more than 'openBracket' 

1. baseCase: did i reach 'maxLength'?
  - if we have reached the maxAllowed 'strLength', that means we got the result
  maxAllowedLength = n * 2

*/
function generateParenthesisHelper(n, str, open, close, result) {

  // 1. baseCase: did i reach 'maxLength'?
  if (str.length === n * 2) {
    // store: the finalStr in the 'resultArr'
    result.push(str);
    return;
  }

  // 2. can i add 'openBracket'?
  if (open < n) {
    generateParenthesisHelper(n, str + "(", open + 1, close, result);
  }

  // 3. can i add 'closeBracket'?
  if (open > close) {
    generateParenthesisHelper(n, str + ")", open, close + 1, result);
  }
}

function generateParenthesis(n) {
  const result = [];
  generateParenthesisHelper(n, "", 0, 0, result);
  return result;
}
```
{% endtab %}

{% tab title="Explanation" %}
```javascript
/*

REMEMBER: Recursion is DFS

gp({"n":2,"str":"","open":0,"close":0,"result":[]})
2. can i add 'openBracket'? // Yes
|
|_gp({"n":2,"str":"(","open":1,"close":0,"result":[]})
  2. can i add 'openBracket'? // Yes
  |
  |_gp({"n":2,"str":"((","open":2,"close":0,"result":[]}
    2. can i add 'openBracket'? // No  // reached: maxLimit
    3. can i add 'closeBracket'? // Yes
    |
    |_gp({"n":2,"str":"(()","open":2,"close":1,"result":[]}
      2. can i add 'openBracket'? // No
      3. can i add 'closeBracket'? // Yes
      |
      |_gp({"n":2,"str":"(())","open":2,"close":2,"result":[]}
        1. baseCase: did i reach 'maxLength'? // Yes  //add it in the 'resultArr' and return  // {"n":2,"str":"(())","open":2,"close":2,"result":["(())"]}
        |
       _|
      |
     _| 
    |
   _|
  |
  |
  3. can i add 'closeBracket'? // Yes
  |
  |_gp({"n":2,"str":"()","open":1,"close":1,"result":["(())"]}
    2. can i add 'openBracket'? // Yes
    |
    |_gp({"n":2,"str":"()(","open":2,"close":1,"result":["(())"]}
      2. can i add 'openBracket'? // No
      3. can i add 'closeBracket'? // Yes
      |
      |_gp({"n":2,"str":"()()","open":2,"close":2,"result":["(())"]}
        1. baseCase: did i reach 'maxLength'? // Yes  //add it in the 'resultArr'
        // {"n":2,"str":"(())","open":2,"close":2,"result":["(())", "()()"]}
        |
       _|
      |
     _|
    |
    3. can i add 'closeBracket'? // No
    |
   _|
  |           
 _|           
|
|
// {"n":2,"str":"(())","open":2,"close":2,"result":["(())", "()()"]}


["(())", "()()"]



{"n":3,"str":"","open":0,"close":0,"result":[]}
{"n":3,"str":"(","open":1,"close":0,"result":[]}
{"n":3,"str":"((","open":2,"close":0,"result":[]}
{"n":3,"str":"(((","open":3,"close":0,"result":[]}
{"n":3,"str":"((()","open":3,"close":1,"result":[]}
{"n":3,"str":"((())","open":3,"close":2,"result":[]}
{"n":3,"str":"((()))","open":3,"close":3,"result":[]}
{"n":3,"str":"(()","open":2,"close":1,"result":["((()))"]}
{"n":3,"str":"(()(","open":3,"close":1,"result":["((()))"]}
{"n":3,"str":"(()()","open":3,"close":2,"result":["((()))"]}
{"n":3,"str":"(()())","open":3,"close":3,"result":["((()))"]}
{"n":3,"str":"(())","open":2,"close":2,"result":["((()))","(()())"]}
{"n":3,"str":"(())(","open":3,"close":2,"result":["((()))","(()())"]}
{"n":3,"str":"(())()","open":3,"close":3,"result":["((()))","(()())"]}
{"n":3,"str":"()","open":1,"close":1,"result":["((()))","(()())","(())()"]}
{"n":3,"str":"()(","open":2,"close":1,"result":["((()))","(()())","(())()"]}
{"n":3,"str":"()((","open":3,"close":1,"result":["((()))","(()())","(())()"]}
{"n":3,"str":"()(()","open":3,"close":2,"result":["((()))","(()())","(())()"]}
{"n":3,"str":"()(())","open":3,"close":3,"result":["((()))","(()())","(())()"]}
{"n":3,"str":"()()","open":2,"close":2,"result":["((()))","(()())","(())()","()(())"]}
{"n":3,"str":"()()(","open":3,"close":2,"result":["((()))","(()())","(())()","()(())"]}
{"n":3,"str":"()()()","open":3,"close":3,"result":["((()))","(()())","(())()","()(())"]}

["((()))", "(()())", "(())()", "()(())", "()()()"]

*/
```
{% endtab %}
{% endtabs %}

## [13. Container With Most Water](https://leetcode.com/problems/container-with-most-water)

{% tabs %}
{% tab title="Question" %}
11. Container With Most Water
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=k5fbSqb9sCI" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*
  Using: left & right pointer
  TC: O(n) S: O(1)
*/
function maxArea(barHeights) {
  let start = 0;
  let end = barHeights.length - 1;
  let maxArea = 0;

  while (start < end) {
    const width = end - start;
    const height = Math.min(barHeights[start], barHeights[end]);
    const currArea = width * height;
    maxArea = Math.max(currArea, maxArea); // update: sofarMaxArea

    if (start < end) {
      start++;
    } else {
      end++;
    }
  }

  return maxArea;
}

```
{% endtab %}
{% endtabs %}

## [14. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)

{% tabs %}
{% tab title="Question" %}
Subarray with given sum // find the `noOfSubArr` whose subArrItems sum equals to **k**.

```javascript
Example 1:
-----------
Input: nums = [1,1,1], k = 2
Output: 2 // subArr1 = [1,1]; subArr2 = [1,1] // found: 2 subArr


Example 2:
-----------
Input: nums = [1, 4, 20, 3, 10, 5], k = 33
Output: 1 // subArr1 = [20,3,10]; // found: 1 subArr

```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=AmlVSNBHzJg" %}
{% endtab %}

{% tab title="Code" %}
```javascript
/*
Using: HashMap (PreSum)
  // 1. keep: summing
  // 2. remember: eachSum value in Map
  // 3. if 'sum-k' exists in map, then increment 'noOfSubArr'

TC: O(n) S: O(n)
*/
function subarraySum(nums, k) {
  const map = { 0: 1 };

  let res = 0; // 'noOfSubArr' exists (that subArrSumVal equals to k)
  let sum = 0;

  for (let i = 0; i < nums.length; i++) {
    // 1. keep: summing
    sum = sum + nums[i];

    if (map[sum - k]) {
      // 3. existsInMap: add 'noOfTimesThatSumExistVal' with res
      res = res + map[sum - k];
    }

    // 2. remember: eachSum value
    map[sum] = (map[sum] || 0) + 1;
  }

  // console.log(map);
  return res;
}
```
{% endtab %}

{% tab title="Explanation" %}
```javascript
/*

k=5, possibleSubArray: [3, 2], [3, 1, 1]  // How?

map:   { sum: noOfTimesExists }
{ 0: 1 } // zero exists 1 time

noOfSubArr = 0


[   1,    3,    2,    4,    3,    1,   1   ]
//  *
  sum=0+1=1 ---> sum-k=1-5= -4 //existsInMap? N ----> {0:1, 1:1}

[   1,    3,    2,    4,    3,    1,   1   ]
//        *
//      sum=1+3=4 ---> sum-k=4-5= -1 //existsInMap? N ----> {0:1, 1:1, 4:1}  

[   1,    3,    2,    4,    3,    1,   1   ]
//              *
//            sum=4+2=6 ---> sum-k=6-5= 1 //existsInMap? Yes (1 time) (noOfSubArr = noOfSubArr + 1) ----> {0:1, 1:1, 4:1, 6:1}

[   1,    3,    2,    4,    3,    1,   1   ]
//                    *
//                  sum=6+4=10 ---> sum-k=10-5= 5 //existsInMap? N ----> {0:1, 1:1, 4:1, 6:1, 10:1} 

[   1,    3,    2,    4,    3,    1,   1   ]
//                          *
//                        sum=10+3=13 ---> sum-k=13-5= 8 //existsInMap? N ----> {0:1, 1:1, 4:1, 6:1, 10:1, 13:1} 

[   1,    3,    2,    4,    3,    1,   1   ]
//                                *
//                              sum=13+1=14 ---> sum-k=14-5= 9 //existsInMap? N ----> {0:1, 1:1, 4:1, 7:1, 10:1, 13:1, 14:1} 

[   1,    3,    2,    4,    3,    1,   1   ]
//                                     *
//                                   sum=14+1=15 ---> sum-k=15-5= 10 //existsInMap? Yes (1 time) (noOfSubArr = noOfSubArr + 1) ----> {0:1, 1:1, 4:1, 7:1, 10:1, 13:1, 14:1, 15:1} 




Input: [ 1, 2, 3, -6, 3, 2 ], k=5
possibleSubArray: [2,3], [1,2,3,-6,3,2], [3,2]

map: {0:1}
[      1,      2,      3,      -6,     3,      2     ]

// sum=0+1=1  --->  sum-k=1-5= -4 //notExistsInMap ---> {0:1, 1:1}

//         sum=1+2=3  --->  sum-k=3-5= -1 //notExistsInMap ---> {0:1, 1:1, 3:1}

//                  sum=3+3=6  --->  sum-k=6-5= 1 //existsInMap || res = 0+1 = 1 || ---> {0:1, 1:1, 3:1, 6:1}   

//                          sum=6-6=0  --->  sum-k=0-5= -5 //notExistsInMap ---> {0:2, 1:1, 3:1, 6:1} // '0' alreadyExist 'incrementCounter'

//                                  sum=0+3=3  --->  sum-k=3-5= -2 //notExistsInMap ---> {0:2, 1:1, 3:2, 6:1} // '3' alreadyExist 'incrementCounter'  

//                                           sum=3+2=5  --->  sum-k=5-5= 0 //existsInMap || res = 1+2 = 3 || ---> {0:2, 1:1, 3:2, 6:1, 5:1}


Output: noOfSubArr --> res = 3

*/

```
{% endtab %}
{% endtabs %}

## [15. Decode String](https://leetcode.com/problems/decode-string)

{% tabs %}
{% tab title="Question" %}
394. Decode String // Given an encoded string, return its decoded string.

The encoding rule is: `k[encoded_string]`, 

* where the encoded\_string inside the square brackets is being repeated exactly k times. 
* Note that k is guaranteed to be a positive integer.

```javascript
Examples:
s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
```
{% endtab %}

{% tab title="Video" %}
* [https://www.youtube.com/watch?v=0iQqj5egK9k](https://www.youtube.com/watch?v=0iQqj5egK9k)
* [https://www.youtube.com/watch?v=kNW1SlfDuJY](https://www.youtube.com/watch?v=kNW1SlfDuJY)
{% endtab %}

{% tab title="Sol1" %}
```javascript
/*
Using: Two Stack
  1. numStack: to get the 'lastNumber' we found
  2. strStack: to get the 'lastAccumlatedStr' we found

TC: O(k_max * n) // Time complexity is not O(n) but O(k_max*n)
S: O(n)
*/
var decodeString = function(s) {
  const startBracket = "[";
  const endBracket = "]";

  const numStack = [];
  const strStack = [];
  let currStr = "";
  let currNo = "";

  for (let i = 0; i < s.length; i++) {
    const ch = s.charAt(i);
    if (!isNaN(ch)) {
      currNo += ch;
    } else if (ch === startBracket) {
      numStack.push(parseInt(currNo)); // got the fullDigitNumber, // store 'currNo' in stack
      strStack.push(currStr); // found new '['  // store the 'currStr' in stack // this helps to track 'lastStr'
      // reset: both
      currNo = "";
      currStr = "";
    } else if (ch === endBracket) {
      const lastNum = numStack.pop();
      currStr = currStr.repeat(lastNum);

      const lastStr = strStack.pop();
      currStr = lastStr + currStr;
    } else {
      currStr += ch;
    }
  }

  return currStr;
};
```
{% endtab %}

{% tab title="Explanation" %}
```javascript
/*
----------------------------------------------------------------------
decodeString('12[aa3[b]c]'); ====> return "aabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbc"
----------------------------------------------------------------------

case1: (numbr found)    // append: with currNo

case:2 (openBkt found)
  -storeCurrNumbr: (push: 'currNo' in numStack)
  -storeCurrStr: (push: 'currStr' in numStack)
  -resetCurrNoAndCurrStr: currNo='' | currStr=''

case:3 (closeBkt found)
  -getLastNumbr: (pop: numStack)
  -repeat 'currStr' --> 'lastNumber' times
  -getLastStr: (pop: strStack)
  -append: 'lastStr' with 'currStr'
  

case:4 (str found)      // append: with currStr



"  1 2 [ a a 3 [ b ] c ]  " ----case:1 (numbr found)  ----> currNo='1' | currStr='' | numStack=[] | strStack=[]
// *

"  1 2 [ a a 3 [ b ] c ]  " ----case:1 (numbr found)  ---->  currNo='12' | currStr='' | numStack=[] | strStack=[]
//   *

"  1 2 [ a a 3 [ b ] c ]  " ----case:2 (openBkt found) ---->  currNo='' | currStr='' | numStack=[12] | strStack=['']
//     *                           -storeCurrNumbr: (push: 'currNo' in numStack)  // numStack[12]
//                                 -storeCurrStr: (push: 'currStr' in numStack) // strStack=['']
//                                 -resetCurrNoAndCurrStr: currNo='' | currStr=''


"  1 2 [ a a 3 [ b ] c ]  " ----case:4 (str found) ---->  currNo='' | currStr='a' | numStack=[12] | strStack=['']
//       *

"  1 2 [ a a 3 [ b ] c ]  " ----case:4 (str found) ---->  currNo='' | currStr='a' | numStack=[12] | strStack=['']
//       *

"  1 2 [ a a 3 [ b ] c ]  " ----case:4 (str found) ---->  currNo='' | currStr='aa' | numStack=[12] | strStack=['']
//         *


"  1 2 [ a a 3 [ b ] c ]  " ----case:1 (numbr found) ---->  currNo='3' | currStr='aa' | numStack=[12] | strStack=['']
//           *

"  1 2 [ a a 3 [ b ] c ]  " ----case:2 (openBkt found) ---->  currNo='' | currStr='' | numStack=[12, 3] | strStack=['', 'aa']
//             *                   -storeCurrNumbr: (push: 'currNo' in numStack)  // numStack[12, 3]
//                                 -storeCurrStr: (push: 'currStr' in numStack) // strStack=['', 'aa']
//                                 -resetCurrNoAndCurrStr: currNo='' | currStr=''


"  1 2 [ a a 3 [ b ] c ]  " ----case:4 (str found) ---->  currNo='' | currStr='b' | numStack=[12, 3] | strStack=['', 'aa']
//               *

"  1 2 [ a a 3 [ b ] c ]  " ----case:3 (closeBkt found) ---->  currNo='' | currStr='aabbb' | numStack=[12] | strStack=['']
//                 *               -getLastNumbr: (pop: numStack)   // 3
//                                 -repeat 'currStr' --> '3' times  //  'bbb'
//                                 -getLastStr: (pop: strStack)   // 'aa'
//                                 -append: 'lastStr' with 'currStr' // 'aa' + 'bbb'  // 'aabbb'


"  1 2 [ a a 3 [ b ] c ]  " ----case:4 (str found) ---->  currNo='' | currStr='aabbbc' | numStack=[12] | strStack=['']
//                   *


"  1 2 [ a a 3 [ b ] c ]  " ----case:3 (closeBkt found) ---->  currNo='' | currStr='aabbb' | numStack=[12] | strStack=['']
//                     *           -getLastNumbr: (pop: numStack)   // 12
//                                 -repeat 'currStr' --> '12' times  //  12 * 'aabbbc' = aabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbc
//                                 -getLastStr: (pop: strStack)   // ''
//                                 -append: 'lastStr' with 'currStr' // '' + 'aabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbcaabbbc'

*/

```
{% endtab %}

{% tab title="SameSol1\(using oneStack\)" %}
```javascript
// using: single stack  [It is the same performance]
// just for undertsanding, instead of using 2 different stack, use: singleStack
var decodeString = function(s) {
  let stack = [];
  let currNo = 0;
  let currStr = "";

  for (let c of s) {
    if (!isNaN(ch)) {
      currNo = currNo * 10 + Number(c);
    } else if (c === "[") {
      stack.push(currStr);
      stack.push(currNo);
      currNo = 0;
      currStr = "";
    } else if (c === "]") {
      let currCount = stack.pop();
      let lastStr = stack.pop();
      currStr = lastStr + currStr.repeat(currCount);
    } else {
      currStr += c;
    }
  }

  return currStr;
};
```
{% endtab %}
{% endtabs %}

## [16. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number)

{% tabs %}
{% tab title="Question" %}
17. Letter Combinations of a Phone Number

Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters \(just like on the telephone buttons\) is given below. Note that 1 does not map to any letters.

![](http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

```javascript
Example:
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=VWzTExgYpBM" %}

{% embed url="https://www.youtube.com/watch?v=OylOLR4bqdA" %}
{% endtab %}

{% tab title="Sol1: BFS \[BEST\]" %}
```javascript
const dialpadMap = {
  2: ["a", "b", "c"],
  3: ["d", "e", "f"],
  4: ["g", "h", "i"],
  5: ["j", "k", "l"],
  6: ["m", "n", "o"],
  7: ["p", "q", "r", "s"],
  8: ["t", "u", "v"],
  9: ["w", "x", "y", "z"]
};

/*
  Using BFS
  TC: 4^n  SC: 4^n
*/
function letterCombinations(digits) {
  if (!digits) return [];
  let results = [...dialpadMap[digits[0]]];

  for (let i = 1; i < digits.length; i++) {
    const letters = dialpadMap[digits[i]]; // dialpadMap[eachDigit]
    const tmpArr = [];
    for (let combination of results) {
      for (let letter of letters) {
        tmpArr.push(combination + letter);
      }
    }
    results = tmpArr;
  }

  return results;
}

console.log(letterCombinations("234"));
```
{% endtab %}

{% tab title="Sol1: Explanation" %}
```javascript
/*

// *2 3 4                                    a                                       b                                       c
//                                 /         |         \                  /          |          \                 /          |          \
// 2 *3 4                       ad          ae          af              bd          be          bf              cd          ce           cf
//                            /  |  \     /  |  \     /  |  \         /  |  \     /  |  \     /  |  \         /  |  \     /  |  \      /  |  \
// 2 3 *4                   adg adh adi aeg aeh aei  afg afh afi    bdg bdh bdi beg beh bei bfg bfh bfi     cdg cdh cdi ceg ceh cei  cfg cfh cfi




//          letters                   results
2 3 4     ["a", "b", "c"]           ["a", "b", "c"]
*

2 3 4     ["d", "e", "f"]           ["ad", "ae", "af",      "bd", "be", "bf",     "cd", "ce", "cf"]
  *


2 3 4     ["g", "h", "i"]           ["adg", "adh", "adi",    "aeg", "aeh", "aei",   "afg", "afh", "afi", 
//  *                                "bdg", "bdh", "bdi",    "beg", "beh", "bei",   "bfg", "bfh", "bfi", 
//                                   "cdg", "cdh", "cdi",    "ceg", "ceh", "cei",   "cfg", "cfh", "cfi"]


*/
```
{% endtab %}

{% tab title="Sol2: DFS" %}
```javascript

function backtrack(combination, nextDigits, output) {
  // base case:
  if (nextDigits.length == 0) {
    // if there is no more digits to check
    // the combination is done
    output.push(combination);
  } else {
    // if there are still digits to check
    // iterate over all letters which map the next available digit
    let currDigit = nextDigits[0];
    let letters = dialpadMap[currDigit];
    for (let letter of  letters) {
      // append the current letter to the combination and proceed to the 'nextDigits'
      backtrack(combination + letter, nextDigits.substring(1), output);
    }
  }
}
/*
  Using DFS (Recurssion & Backtracking)
  TC: 4^n  SC: 4^n
*/
function letterCombinationsDFS(digits) {
  const output = [];
  if (digits.length != 0) {
    backtrack("", digits, output);
  }
  return output;
}
console.log(letterCombinationsDFS("234"));
```
{% endtab %}
{% endtabs %}

## [17. Word Search](https://leetcode.com/problems/word-search)

{% tabs %}
{% tab title="Question" %}
79. Word Search  // similar to isLand problem

* Given a 2D board and a word, find if the word exists in the grid.
  * The word can be constructed from letters of sequentially adjacent cell, 
  * where "adjacent" cells are those horizontally or vertically neighboring. 
* The **same letter 'cell' cannot be used more than once**.

```javascript
Condition:
 - you can combine chars 'vertically' or 'horizontally'  // you cannot go diagonal
 - same letter 'cell' cannot be used more than once.

Input: 
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Input:  word = "ABCCED" --> Output: true
Input:  word = "SEE"    --> Output: true
Input:  word = "ABC"    --> Output: true
Input:  word = "ABCB"   --> Output: false   // becoz 'ABC' is available, but 'ABC'

Input:  word = "SFDA"     --> Output: true
Input:  word = "SFDAS"    --> Output: false // becoz 's' is already visited

```
{% endtab %}

{% tab title="Video" %}
{% embed url="https://www.youtube.com/watch?v=m9TrOL1ETxI" %}

* [https://www.youtube.com/watch?v=HneGZZ3WxFY](https://www.youtube.com/watch?v=HneGZZ3WxFY)
{% endtab %}

{% tab title="Sol1:" %}
```javascript
/*
TC is O(M * N * 4^L)
 - M*N is the size of the board
 - L is the length of the word; // because of the recursion it is 4^L

 SC: O(M * N)  extra space used for 'visitedGrid'
*/

function dfs(board, i, j, word, index, visitedGrid) {
    if (index === word.length) {
        // we have seen the entire word
        return true;
    }

    if (
        (i < 0 || i >= board.length) || // isOutOfRowBoundry
        (j < 0 || j >= board[i].length) || // isOutOfColBoundry
        board[i][j] !== word[index] || //isNotSameChar
        visitedGrid[i][j] // isAlreadyVisited
    ) {
        return false;
    }

    visitedGrid[i][j] = true; // assuming we 'visited' the currNode

    // const myNextCharIdx = 'index + 1'
    if (
        dfs(board, i - 1, j, word, index + 1, visitedGrid) || // isLeftItem
        dfs(board, i + 1, j, word, index + 1, visitedGrid) || // isRightItem
        dfs(board, i, j - 1, word, index + 1, visitedGrid) || // isTopItem
        dfs(board, i, j + 1, word, index + 1, visitedGrid) // isBottomItem
    ) {
        return true;
    }

    visitedGrid[i][j] = false; // our assumption is wrong, marking currNode as 'notVisited'
    return false;
}

function exist(board, word) {
    const rows = board.length;
    const cols = board[0].length;

    // to mark visitedItem
    var visitedGrid = [...Array(rows)].map(()=> Array(cols));

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            // isCurChar: matchingFirstChar && 'nextChars' matchingLeftOrRightOrTopOrBottom
            if (word[0] === board[i][j] && dfs(board, i, j, word, 0, visitedGrid)) {
                return true;
            }
        }
    }

    return false;
}

```
{% endtab %}

{% tab title="Explanation" %}
```

```
{% endtab %}

{% tab title="Sol2: noExtraSpace \[BEST\]" %}
```javascript
// Same Sol1, without extra space for 'visitedGrid'
// instead marking visited nodes as '#'

function dfs(board, i, j, word, index) {
  if (index === word.length) {
    // we have seen the entire word
    return true;
  }

  if (
    (i < 0 || i >= board.length) || // isOutOfRowBoundry
    (j < 0 || j >= board[i].length) || // isOutOfColBoundry
    board[i][j] !== word[index] //isNotSameChar
  ) {
    return false;
  }

  const tmp = board[i][j];
  board[i][j] = "#"; // assuming we 'visited' the currNode

  // const myNextCharIdx = 'index + 1'
  if (
    dfs(board, i - 1, j, word, index + 1) || // isLeftItem
    dfs(board, i + 1, j, word, index + 1) || // isRightItem
    dfs(board, i, j - 1, word, index + 1) || // isTopItem
    dfs(board, i, j + 1, word, index + 1) // isBottomItem
  ) {
    return true;
  }

  board[i][j] = tmp; // our assumption is wrong, marking currNode as 'notVisited'
  return false;
}

function exist(board, word) {
  const rows = board.length;
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      // isCurChar: matchingFirstChar && 'nextChars' matchingLeftOrRightOrTopOrBottom
      if (word[0] === board[i][j] && dfs(board, i, j, word, 0)) {
        return true;
      }
    }
  }

  return false;
}

```
{% endtab %}
{% endtabs %}

## [18. Next Permutation](https://leetcode.com/problems/next-permutation) \[TODO\]

{% tabs %}
{% tab title="Question" %}
31. Next Permutation

* Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
* If such arrangement is not possible, it must rearrange it as the lowest possible order \(ie, sorted in ascending order\).
* The replacement must be in-place and use only constant extra memory.

```javascript
Here are some examples. 
Inputs are in the left-hand column 
and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## [19. Permutations](https://leetcode.com/problems/permutations) \[TODO\]

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## [20. Word Break](https://leetcode.com/problems/word-break)

{% tabs %}
{% tab title="Question" %}
check: `inputStr` can be segmented into a separated dictionary words

```javascript
Example 1:
-----------
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".

Example 2:
-----------
Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true

Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.

Example 3:
-----------
Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
```
{% endtab %}

{% tab title="Video" %}
* [https://www.youtube.com/watch?v=hLQYQ4zj0qg&t=1013s](https://www.youtube.com/watch?v=hLQYQ4zj0qg&t=1013s)
* [https://www.youtube.com/watch?v=RPeTFTKwjps&t=182s](https://www.youtube.com/watch?v=RPeTFTKwjps&t=182s)
{% endtab %}

{% tab title="Sol3: dp \[BEST\]" %}
```javascript
/*
Using 'DP' (Bottom Up Approach)

TC : O(n^2) // Two loops are their to fill 'dpArr'
SC : O(n)   // Length of dp array is n+1
*/
function wordBreak(s, wordDictArr) {
  const wordDict = new Set(wordDictArr);
  const dp = [];

  // base case: //bottom-up-approach
  dp[0] = true;

  // loop: lengthLoop
  for (let len = 1; len <= s.length; len++) {
    // loop: strLoop
    for (let i = 0; i < len; i++) {
      const currStr = s.substring(i, len);
      if (dp[i] && wordDict.has(currStr)) {
        dp[len] = true;
        break;
      }
    }
  }

  return !!dp[s.length];
}

```
{% endtab %}

{% tab title="Sol3: Explanation" %}
```javascript
console.log(wordBreak("code", ["c", "od", "e", "x"])); // true

/*
input: 'C'

dp: [ T ] // base case:  //bottom-up-approach
.     0

#lengthLoop               

len=1  -->  strLoop: [0]        ---> dp: [ T, *T ]
------------------------------------------
  ##strLoop --> currStr : ['c']

  |- dp[0] && inDict('c')   // true


len=2  -->  strLoop: [0,1]      ---> dp: [ T, T, *F ]
------------------------------------------
  ##strLoop --> currStr : ['co', 'o']

  |- dp[0] && inDict('co')  // false
  |- dp[1] && inDict('o')   // false


len=3  -->  strLoop: [0,1,2]      ---> dp: [ T, T, F, *T ] 
------------------------------------------
  ##strLoop --> currStr : ['cod', 'od', 'd']
  |- dp[0] && inDict('cod') // false
  |- dp[1] && inDict('od')  // true
  |- dp[2] && inDict('d')   // false 


len=4  -->  strLoop: [0,1,2,3]    ---> dp: [ T, T, F, T, *T ] 
------------------------------------------
  ##strLoop --> currStr : ['code', 'ode', 'de', 'e']
  |- dp[0] && inDict('code') // false
  |- dp[1] && inDict('ode')  // false
  |- dp[2] && inDict('de')   // false
  |- dp[3] && inDict('e')    // true

Ans: dp[strLen] ---> dp[4] // true
*/




console.log(wordBreak("catsandog", ["cats", "dog", "and"])); // false

/*

dp: [ T ] // base case:  //bottom-up-approach

#lengthLoop               

len=1  -->  strLoop: [0]        ---> dp: [T, *F]
------------------------------------------
  |- dp[0] && inDict('c')  // false

len=2  -->  strLoop: [0,1]      ---> dp: [T, F, *F]
------------------------------------------
  |- dp[0] && inDict('ca')  // false
  |- dp[1] && inDict('a')   // false

len=3  -->  strLoop: [0,1,2]      ---> dp: [T, F, F, *F]
------------------------------------------
  |- dp[0] && inDict('cat')    // false
  |- dp[1] && inDict('at')     // false
  |- dp[2] && inDict('t')      // false

len=4  -->  strLoop: [0,1,2,3]    ---> dp: [T, F, F, F, *T]
------------------------------------------
  |- dp[0] && inDict('cats')  // true
  |- dp[1] && inDict('ats')   // false
  |- dp[2] && inDict('ts')    // false
  |- dp[3] && inDict('s')     // false

len=5  -->  strLoop: [0,1,..4]    ---> dp: [T, F, F, F, T, *F]
------------------------------------------
  |- dp[0] && inDict('catsa')   // false
  |- dp[1] && inDict('atsa')    // false
  |- dp[2] && inDict('tsa')     // false
  |- dp[3] && inDict('sa')      // false
  |- dp[4] && inDict('a')       // false

len=6  -->  strLoop: [0,1,..5]    ---> dp: [T, F, F, F, T, F, *F]
------------------------------------------
  |- dp[0] && inDict('catsan')  // false
  |- dp[1] && inDict('atsan')   // false
  |- dp[2] && inDict('tsan')    // false
  |- dp[3] && inDict('san')     // false
  |- dp[4] && inDict('an')      // false
  |- dp[5] && inDict('n')       // false

len=7  -->  strLoop: [0,1,..6]    ---> dp: [T, F, F, F, T, F, F, *T]
------------------------------------------
  |- dp[0] && inDict('catsand')   // false
  |- dp[1] && inDict('atsand')    // false
  |- dp[2] && inDict('tsand')     // false
  |- dp[3] && inDict('sand')      // false
  |- dp[4] && inDict('and')       // true
  |- dp[5] && inDict('nd')        // false
  |- dp[6] && inDict('d')         // false

len=8  -->  strLoop: [0,1,..7]    ---> dp: [T, F, F, F, T, F, F, T, *F]
------------------------------------------
  |- dp[0] && inDict('catsando')  // false
  |- dp[1] && inDict('atsando')   // false
  |- dp[2] && inDict('tsando')    // false
  |- dp[3] && inDict('sando')     // false
  |- dp[4] && inDict('ando')      // false
  |- dp[5] && inDict('ndo')       // false
  |- dp[6] && inDict('do')        // false
  |- dp[7] && inDict('o')         // false

len=9  -->  strLoop: [0,1,..8]    ---> dp: [T, F, F, F, T, F, F, T, F, *F]
------------------------------------------
  |- dp[0] && inDict('catsandog') // false
  |- dp[1] && inDict('atsandog')  // false
  |- dp[2] && inDict('tsandog')   // false
  |- dp[3] && inDict('sandog')    // false
  |- dp[4] && inDict('andog')     // false
  |- dp[5] && inDict('ndog')      // false
  |- dp[6] && inDict('dog')       // false
  |- dp[7] && inDict('og')        // false
  |- dp[8] && inDict('g')         // false


Ans: dp[strLen] ---> dp[9] // false

*/




console.log(wordBreak("catsanddog", ["cats", "dog", "and"])); // true

/*

dp: [ T ] // base case:  //bottom-up-approach

#lengthLoop       

len=1  -->  strLoop: [0]        ---> dp: [T, *F]
------------------------------------------
  |- dp[0] && inDict('c')  // false

len=2  -->  strLoop: [0,1]      ---> dp: [T, F, *F]
------------------------------------------
  |- dp[0] && inDict('ca')  // false
  |- dp[1] && inDict('a')  // false

len=3  -->  strLoop: [0,1,2]    ---> dp: [T, F, F, *F]
------------------------------------------
  |- dp[0] && inDict('cat')  // false
  |- dp[1] && inDict('at')  // false
  |- dp[2] && inDict('t')  // false

len=4  -->  strLoop: [0,1,2,3]    ---> dp: [T, F, F, F, *T]
------------------------------------------
  |- dp[0] && inDict('cats')  // true

len=5  -->  strLoop: [0,1,..4]    ---> dp: [T, F, F, F, T, *F]
------------------------------------------
  |- dp[0] && inDict('catsa')  // false
  |- dp[1] && inDict('atsa')  // false
  |- dp[2] && inDict('tsa')  // false
  |- dp[3] && inDict('sa')  // false
  |- dp[4] && inDict('a')  // false
  
len=6  -->  strLoop: [0,1,..5]    ---> dp: [T, F, F, F, T, F, *F]
------------------------------------------
  |- dp[0] && inDict('catsan')  // false
  |- dp[1] && inDict('atsan')  // false
  |- dp[2] && inDict('tsan')  // false
  |- dp[3] && inDict('san')  // false
  |- dp[4] && inDict('an')  // false
  |- dp[5] && inDict('n')  // false
  
len=7  -->  strLoop: [0,1,..6]    ---> dp: [T, F, F, F, T, F, F, *T]
------------------------------------------
  |- dp[0] && inDict('catsand')  // false
  |- dp[1] && inDict('atsand')  // false
  |- dp[2] && inDict('tsand')  // false
  |- dp[3] && inDict('sand')  // false
  |- dp[4] && inDict('and')  // true
  
len=8  -->  strLoop: [0,1,..7]    ---> dp: [T, F, F, F, T, F, F, T, *F]
------------------------------------------
  |- dp[0] && inDict('catsandd')  // false
  |- dp[1] && inDict('atsandd')  // false
  |- dp[2] && inDict('tsandd')  // false
  |- dp[3] && inDict('sandd')  // false
  |- dp[4] && inDict('andd')  // false
  |- dp[5] && inDict('ndd')  // false
  |- dp[6] && inDict('dd')  // false
  |- dp[7] && inDict('d')  // false
  
len=9  -->  strLoop: [0,1,..8]    ---> dp: [T, F, F, F, T, F, F, T, F, *F]
------------------------------------------
  |- dp[0] && inDict('catsanddo')  // false
  |- dp[1] && inDict('atsanddo')  // false
  |- dp[2] && inDict('tsanddo')  // false
  |- dp[3] && inDict('sanddo')  // false
  |- dp[4] && inDict('anddo')  // false
  |- dp[5] && inDict('nddo')  // false
  |- dp[6] && inDict('ddo')  // false
  |- dp[7] && inDict('do')  // false
  |- dp[8] && inDict('o')  // false
  
len=10  -->  strLoop: [0,1,..9]    ---> dp: [T, F, F, F, T, F, F, T, F, F, *T]
------------------------------------------
  |- dp[0] && inDict('catsanddog')  // false
  |- dp[1] && inDict('atsanddog')  // false
  |- dp[2] && inDict('tsanddog')  // false
  |- dp[3] && inDict('sanddog')  // false
  |- dp[4] && inDict('anddog')  // false
  |- dp[5] && inDict('nddog')  // false
  |- dp[6] && inDict('ddog')  // false
  |- dp[7] && inDict('dog')  // true


Ans: dp[strLen] ---> dp[10] // true

*/
```
{% endtab %}
{% endtabs %}

## [21. Coin Change](https://leetcode.com/problems/coin-change)

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Sol2: dp" %}
```javascript
/*
Using: DP // bottom-up-approach

// A: amount, c: noOfCoins
TC: O(A*c) 
SC: O(A)
*/

function coinChange(coins, amount) {
  // We use this to fill the dp table with default values
  let max = amount + 1;

  // This table will store the answer to our sub problems
  const dp = new Array(max).fill(max);

  // base case: for amount '0', 0 coins reqd
  dp[0] = 0;

  // solve every subproblem from 1 to amount
  for (let curAmnt = 1; curAmnt <= amount; curAmnt++) {
    // loop: eachCoin
    for (let curCoin of coins) {

      // we can ignore the largerCoins (compare to 'curAmnt')
      if (curCoin <= curAmnt) {
        // Try it. See if it gives us a more optimal solution
        // Try getting 'curMin' from already solvedVal
        // TODO: need better explanation
        const curMin = dp[curAmnt - curCoin] + 1;
        dp[curAmnt] = Math.min(dp[curAmnt], curMin);
      }
    }
  }

  // dp[amount] has our answer.
  // If we do not have an answer
  // then dp[amount] will be amount + 1 and hence dp[amount] > amount will be true.
  // We then return -1. Otherwise, dp[amount] holds the answer
  return dp[amount] > amount ? -1 : dp[amount];
}

console.log(coinChange([1, 2, 5], 11)); // 3 // 5+5+2
```
{% endtab %}

{% tab title="Sol2: Explanation" %}
```

/*

#curAmnt: 0
------------
// need atleast '0 coin' to make fullAmount:0

 *0   1    2    3    4    5    6    7    8    9    10   11
 ----------------------------------------------------------
| 0 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 |
 ----------------------------------------------------------
 
#############################################################################

#curAmnt: 1
------------
c:1 --> 1-1 ==> 0 --> dp[0]: 0 --> min(12, 0+1) //winner
c:2 // ignore: largerCoins
c:5 // ignore: largerCoins

// need atleast '1 coin' to make fullAmount:1
update: dp[1]=1

  0  *1    2    3    4    5    6    7    8    9    10   11
 ----------------------------------------------------------
| 0 | 1 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 |
 ----------------------------------------------------------

#############################################################################

#curAmnt: 2
------------
c:1 --> 2-1 ==> 1 --> dp[1]: 1 --> min(12, 1+1)
c:2 --> 2-2 ==> 0 --> dp[0]: 0 --> min(2, 0+1)  //winner
c:5 // ignore: largerCoins

// need atleast '1 coin' to make fullAmount:2
update: dp[2]=1

  0   1   *2    3    4    5    6    7    8    9    10   11
 --------------------------------------------------------
| 0 | 1 | 1 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 |
 --------------------------------------------------------

#############################################################################

#curAmnt: 3
------------
c:1 --> 3-1 ==> 2 --> dp[2]: 1 --> min(12, 1+1)//winner
c:2 --> 3-2 ==> 1 --> dp[1]: 1 --> min(2, 1+1) //nochange
c:5 // ignore: largerCoins

// need atleast '2 coin' to make fullAmount:3
update: dp[3]=2 

  0   1   2   *3   4    5    6    7    8    9    10   11
 --------------------------------------------------------
| 0 | 1 | 1 | 2 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 |
 --------------------------------------------------------

#############################################################################

#curAmnt: 4
------------
c:1 --> 4-1 ==> 3 --> dp[3]: 2 --> min(12, 2+1)
c:2 --> 4-2 ==> 2 --> dp[2]: 1 --> min(3, 1+1)  //winner
c:5 // ignore: largerCoins

// need atleast '2 coin' to make fullAmount:4
update: dp[4]=2 

  0   1   2   3  *4   5    6    7    8    9    10   11
 -------------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 12 | 12 | 12 | 12 | 12 | 12 | 12 |
 -------------------------------------------------------

#############################################################################

#curAmnt: 5
------------
c:1 --> 5-1 ==> 4 --> dp[4]: 2 --> min(12, 2+1)
c:2 --> 5-2 ==> 3 --> dp[3]: 2 --> min(3, 2+1)
c:5 --> 5-5 ==> 0 --> dp[0]: 0 --> min(3, 0+1)  //winner 

// need atleast '2 coin' to make fullAmount:5
update: dp[5]=1 

  0   1   2   3  4   *5   6    7    8    9    10   11
 ------------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 12 | 12 | 12 | 12 | 12 | 12 |
 ------------------------------------------------------

#############################################################################

#curAmnt: 6
------------
c:1 --> 6-1 ==> 5 --> dp[5]: 1 --> min(12, 1+1) //winner 
c:2 --> 6-2 ==> 4 --> dp[4]: 2 --> min(2, 2+1)
c:5 --> 6-5 ==> 1 --> dp[1]: 1 --> min(2, 1+1)  //nochange 

// need atleast '2 coin' to make fullAmount:6
update: dp[6]=2 

  0   1   2   3   4   5  *6   7    8    9    10   11
 -----------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 2 | 12 | 12 | 12 | 12 | 12 |
 -----------------------------------------------------

#############################################################################

#curAmnt: 7
------------
c:1 --> 7-1 ==> 6 --> dp[6]: 2 --> min(12, 2+1)
c:2 --> 7-2 ==> 5 --> dp[5]: 1 --> min(3, 1+1)  //winner
c:5 --> 7-5 ==> 2 --> dp[2]: 1 --> min(2, 1+1)  //nochange 

// need atleast '2 coin' to make fullAmount:7
update: dp[7]=2 

  0   1   2   3   4   5   6   *7   8    9    10   11
 ---------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 12 | 12 | 12 | 12 |
 ---------------------------------------------------

#############################################################################


#curAmnt: 8
------------
c:1 --> 8-1 ==> 7 --> dp[7]: 2 --> min(12, 2+1) //winner
c:2 --> 8-2 ==> 6 --> dp[6]: 2 --> min(3, 2+1)  //nochange
c:5 --> 8-5 ==> 3 --> dp[3]: 2 --> min(2, 2+1)  //nochange 

// need atleast '3 coin' to make fullAmount:8
update: dp[8]=3 

  0   1   2   3   4   5   6   7   *8   9    10   11
 --------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 12 | 12 | 12 |
 --------------------------------------------------

#############################################################################

#curAmnt: 9
------------
c:1 --> 9-1 ==> 8 --> dp[8]: 3 --> min(12, 3+1)
c:2 --> 9-2 ==> 7 --> dp[7]: 2 --> min(4, 2+1)  //winner
c:5 --> 9-5 ==> 4 --> dp[4]: 2 --> min(3, 2+1)  //nochange 

// need atleast '3 coin' to make fullAmount:9
update: dp[9]=3 

  0   1   2   3   4   5   6   7   8   *9  10   11
 -------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 12 | 12 |
 -------------------------------------------------

#############################################################################

#curAmnt: 10
------------
c:1 --> 10-1 ==> 9 --> dp[9]: 3 --> min(12, 3+1)
c:2 --> 10-2 ==> 8 --> dp[8]: 3 --> min(4, 3+1)
c:5 --> 10-5 ==> 5 --> dp[5]: 1 --> min(4, 1+1)  //winner

// need atleast '2 coin' to make fullAmount:10
update: dp[10]=2 

  0   1   2   3   4   5   6   7   8   9  *10   11
 -------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 2 | 12 |
 -------------------------------------------------

#############################################################################

#curAmnt: 11
------------
c:1 --> 11-1 ==> 10 --> dp[10]: 2 --> min(12, 2+1) //winner
c:2 --> 11-2 ==> 9  -->  dp[9]: 3 --> min(3, 3+1)
c:5 --> 11-5 ==> 6  -->  dp[6]: 2 --> min(3, 2+1)  //nochange

// need atleast '3 coin' to make fullAmount:11
update: dp[11]=3 

  0   1   2   3   4   5   6   7   8   9  10  *11
 ------------------------------------------------
| 0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 2 | 3 |
 ------------------------------------------------

*/
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..\#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

## \#. Xxxxxx Yyyyy

{% tabs %}
{% tab title="Question" %}
...
{% endtab %}

{% tab title="Video" %}

{% endtab %}

{% tab title="Code" %}
```javascript
....
```
{% endtab %}
{% endtabs %}

..

